{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyectos_4/Semana_1/","title":"Semana 1","text":""},{"location":"Proyectos_4/Semana_1/#syllabus","title":"Syllabus","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_1/#boceto-de-proyecto","title":"Boceto de proyecto","text":""},{"location":"Proyectos_4/Semana_3/","title":"Semana 3","text":""},{"location":"Proyectos_4/Semana_3/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_4/","title":"Semana 4","text":""},{"location":"Proyectos_4/Semana_4/#diagrama-de-gant","title":"Diagrama de Gant","text":"<p>https://g.repsona.com/p/gantt/2c7bc4f9-14d3-4a94-8e8b-f547bc3202e3</p>"},{"location":"Proyectos_4/Semana_5/","title":"Semana 5","text":""},{"location":"Proyectos_4/Semana_5/#marco-real-ganar-vale-la-pena","title":"Marco real ganar vale la pena","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_6/","title":"Semana 6","text":""},{"location":"Proyectos_4/Semana_6/#analisis-de-5-fuerzas","title":"An\u00e1lisis de 5 Fuerzas","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_6/#business-model-canvas","title":"Business Model Canvas","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_7/","title":"Semana 7","text":""},{"location":"Proyectos_4/Semana_7/#planeacion-de-costos-y-ciclos-del-proyecto","title":"Planeaci\u00f3n de costos y ciclos del proyecto","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_7/#excel-de-costos","title":"Excel de costos","text":"<p>\ud83d\udcca Ver o descargar Costos.xlsx</p>"},{"location":"Sistemas_Embebidos/Tarea_1/","title":"Tareas","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-1-comparativa-de-microcontroladores","title":"Tarea 1: Comparativa de Microcontroladores","text":"<p>El objetivo de esta tarea es familiarizarnos con los diferentes tipos de microcontroladores y sus caracter\u00edsticas para as\u00ed poder elegir el ideal para nuestros futuros proyectos.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#proyecto-elegido","title":"Proyecto elegido","text":"<p>La comparaci\u00f3n ser\u00e1 en base a un proyecto el cual es un coche autonomo que tiene sensores para poder moverse libremente y as\u00ed saber si tiene un obst\u00e1culo que le impida su movimiento.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#tabla-comparativa","title":"Tabla comparativa","text":"Variables\\Microcontrolador ATmega328P (Arduino Uno) STM32F103C8T6 PIC18F4550 RP2040 (Raspberry Pi Pico) Perif\u00e9ricos 23 I/O, ADC(6), UART, SPI, I\u00b2C, PWM(6) 37 GPIO, ADC, DAC, UART, SPI, I\u00b2C, CAN, USB 35 I/O, ADC(10), UART, SPI, I\u00b2C, USB 2.0, PWM 26 GPIO, ADC(4), UART, SPI, I\u00b2C, PWM, PIO Memoria (Flash/RAM/EEPROM) 32 KB / 2 KB / 1 KB 64 KB / 20 KB / \u2014 32 KB / 2 KB / 256 B 2 MB ext. / 264 KB / \u2014 Ecosistema Arduino IDE STM32CubeIDE, Arduino, PlatformIO MPLAB X, XC8 Compiler SDK C/C++, MicroPython, Arduino Core Costo aprox $150 \u2013 $220 $90 \u2013 $180 $240 \u2013 $290 $100 \u2013 $200 Arquitectura AVR 8 bits ARM Cortex-M3 32 bits PIC 8 bits ARM Cortex-M0+ Dual-core 32 bits Velocidad de trabajo 16 MHz 72 MHz 48 MHz 133 MHz"},{"location":"Sistemas_Embebidos/Tarea_1/#conclusiones","title":"Conclusiones","text":"<ol> <li> <p>STM32F103: Muy buen balance de rendimiento en tiempo real, muchos timers/PWM, captura de entradas para encoders, ADC 12-bit r\u00e1pido, CAN/USB en variantes. Excelente para control PID a alta tasa y fusi\u00f3n b\u00e1sica de sensores.</p> </li> <li> <p>RP2040: Mucha RAM (264 KB), dos n\u00facleos, y PIO para decodificar encoders o protocolos con poca CPU. Ecosistema enorme (SDK C/C++, MicroPython, Arduino).</p> </li> <li> <p>ATmega328P Ecosistema y librer\u00edas accesibles, PWM/ADC suficientes para un proyecto b\u00e1sico, gran comunidad y m\u00e1s familiarizaci\u00f3n con el, pero una CPU lenta, poca RAM/Flash; se queda corto si aumentan sensores/encoders y la tasa de refresco.</p> </li> <li> <p>PIC18F4550: Robusto e industrial; USB nativo. Menos poder efectivo (8-bit), ecosistema/herramientas menos \u00e1giles para rob\u00f3tica, timers/ADC suficientes pero te quedar\u00e1s antes que con STM32/RP2040.</p> </li> </ol>"},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-2-outputs-basicos","title":"Tarea 2: Outputs B\u00e1sicos","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#contador-binario-4-bits","title":"Contador binario 4 bits","text":"<p>En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define LEDS_MASK ((1&lt;&lt;0) | (1&lt;&lt;1) | (1&lt;&lt;3) | (1&lt;&lt;4))   \nint main() {\n    stdio_init_all();\n\n    gpio_init(0); gpio_set_dir(0, GPIO_OUT);\n    gpio_init(1); gpio_set_dir(1, GPIO_OUT);\n    gpio_init(3); gpio_set_dir(3, GPIO_OUT);\n    gpio_init(4); gpio_set_dir(4, GPIO_OUT);\n\n    int estado = 0;\n\n    while (1) {\n        for (estado = 0; estado &lt; 16; estado++) {\n            gpio_put(0, estado &amp; (1&lt;&lt;0));\n            gpio_put(1, estado &amp; (1&lt;&lt;1));\n            gpio_put(3, estado &amp; (1&lt;&lt;2));  \n            gpio_put(4, estado &amp; (1&lt;&lt;3));\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#barrido-de-leds","title":"Barrido de leds","text":"<p>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0  \n#define LED1 1  \n#define LED2 3  \n#define LED3 4  \n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3}; // lo hice as\u00ed para no repetir 4 lineas de c\u00f3digo\n\nint main() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int posicion = 0;\n    int dir = 1;  \n\n    while (true) {\n        gpio_clr_mask(LED_MASK); \n\n        uint32_t bit = (1u &lt;&lt; LEDS[posicion]);\n        gpio_set_mask(bit);      \n\n        sleep_ms(300);\n\n        posicion += dir;\n\n        if (posicion == 4 || posicion == -1) {\n            gpio_clr_mask(LED_MASK);\n            dir = -dir;  \n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-sistema","title":"Diagrama del sistema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_1","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#secuencia-en-codigo-gray","title":"Secuencia en codigo Gray","text":"<p>Transformar c\u00f3digo binario en una secuencia en c\u00f3digo Gray</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\nint main() {\n\n    const uint LEDS[] = {0, 1, 3, 4};\n    const int Cantidad = 4;\n\n\n    for (int i = 0; i &lt; Cantidad; i++) {//Para evitar c\u00f3digo si son muchos pines\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], GPIO_OUT);\n    }\n\n    while (true) {\n\n        for (int n = 0; n &lt; 16; n++) {\n            int gray = n ^ (n &gt;&gt; 1); // F\u00f3rmula para convertir a Gray\n\n\n            for (int i = 0; i &lt; Cantidad; i++) {\n                int bit = (gray &gt;&gt; i) &amp; 1;\n                gpio_put(LEDS[i], bit);\n            }\n\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito_1","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_2","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-3-inputs","title":"Tarea 3: Inputs","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#compuertas-basicas-and-or-xor-con-2-botones","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>Qu\u00e9 debe hacer: Con dos botones A y B enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_3","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED   0\n#define LED2    1\n#define LED3   3\n\n#define Boton1   5\n#define Boton2   6\n\nint main() {\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(LED2);\n    gpio_set_dir(LED2, true);\n\n    gpio_init(LED3);\n    gpio_set_dir(LED3, true);\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);\n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);\n    gpio_pull_up(Boton2);\n\n    while (true) {\n        // Se invierte para que sea Pull-up\n        uint32_t b1 = !gpio_get(Boton1);\n        uint32_t b2 = !gpio_get(Boton2);\n\n        uint32_t AND = b1 &amp; b2;   \n        uint32_t OR  = b1 | b2; \n        uint32_t XOR = b1 ^ b2;\n\n        gpio_clr_mask((1u &lt;&lt; LED) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3));\n        gpio_set_mask((AND &lt;&lt; LED) |\n                      (OR  &lt;&lt; LED2)  |\n                      (XOR &lt;&lt; LED3));\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito_2","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_3","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#selector-ciclico-de-4-leds-con-avanceretroceso","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>Qu\u00e9 debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso y si dejas presionado no repite. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_4","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0  \n#define LED1 1  \n#define LED2 3  \n#define LED3 4  \n\n#define Boton1 5\n#define Boton2 6\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);  \n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);  \n    gpio_pull_up(Boton2);\n\n    int posicion = 0;\n    uint32_t Estadob1 = true;\n    uint32_t Estadob2 = true;\n\n    while (true) {\n        // Poner posici\u00f3n actual\n        gpio_clr_mask(LED_MASK);\n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]);\n\n\n        uint32_t Avance = gpio_get(Boton1);\n        uint32_t Retroceso = gpio_get(Boton2);\n\n        if (!Avance &amp;&amp; Estadob1) {\n            posicion++;\n            if (posicion &gt; 3) posicion = 0;\n        }\n\n        if (!Retroceso &amp;&amp; Estadob2) {\n            posicion--;\n            if (posicion &lt; 0) posicion = 3;\n        }\n\n        Estadob1 = Avance;\n        Estadob2 = Retroceso;\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito_3","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_4","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-4-ping-pong","title":"Tarea 4: Ping-Pong","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#reglas-del-juego","title":"Reglas del juego","text":"<ol> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> </li> <li> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ol>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_5","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Led 0\n#define Led2 1\n#define Led3 2   // LED central\n#define Led4 3\n#define Led5 4\n#define Led6p 6  \n#define Led7p 8   \n\n#define BotonIzq 14     \n#define BotonDer 15     \n\n#define LED_MASK ((1u &lt;&lt; Led) | (1u &lt;&lt; Led2) | (1u &lt;&lt; Led3) | (1u &lt;&lt; Led4) | (1u &lt;&lt; Led5))\n\nconst uint LEDS[5] = {Led, Led2, Led3, Led4, Led5};\nint posicion = 2;  \nint dir = 1;        \nbool fallo = false;\nint fallo_jugador = -1; \n\n// ISR para botones\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (posicion == 0 &amp;&amp; gpio == BotonIzq) {\n        dir = 1;\n    } else if (posicion == 4 &amp;&amp; gpio == BotonDer) {\n        dir = -1;\n    } else {\n        fallo = true;\n        if (gpio == BotonIzq) {\n            fallo_jugador = 0; \n        } else if (gpio == BotonDer) {\n            fallo_jugador = 1; \n        }\n    }\n}\n\n\nvoid Inicioled() {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(Led3, 1);\n        sleep_ms(500);\n        gpio_put(Led3, 0); \n        sleep_ms(500);\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 5; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Led6p);\n    gpio_set_dir(Led6p, true);\n    gpio_init(Led7p);\n    gpio_set_dir(Led7p, true);\n\n    gpio_init(BotonIzq);\n    gpio_set_dir(BotonIzq, false);\n    gpio_pull_up(BotonIzq);\n    gpio_set_irq_enabled_with_callback(BotonIzq, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n    gpio_init(BotonDer);\n    gpio_set_dir(BotonDer, false);\n    gpio_pull_up(BotonDer);\n    gpio_set_irq_enabled_with_callback(BotonDer, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n\n    Inicioled();\n\n    while (true) {\n        gpio_clr_mask(LED_MASK); \n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]); \n\n        sleep_ms(300);\n\n        if (fallo) {\n            gpio_clr_mask(LED_MASK);\n\n            if (fallo_jugador == 0) {\n                gpio_put(Led6p, 1);\n                sleep_ms(5000);\n                gpio_put(Led6p, 0);\n            } else if (fallo_jugador == 1) {\n                gpio_put(Led7p, 1);\n                sleep_ms(5000);\n                gpio_put(Led7p, 0);\n            }\n\n            // reiniciar juego\n            fallo = false;\n            fallo_jugador = -1;\n            posicion = 2;\n            dir = 1;\n\n\n            Inicioled();\n            continue;\n        }\n\n        posicion += dir;\n\n        // Rebote fallido\n        if (posicion &lt; 0) {\n            fallo = true;\n            fallo_jugador = 0;\n        } else if (posicion &gt; 4) {\n            fallo = true;\n            fallo_jugador = 1;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquema","title":"Esquema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_5","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-5-ejercicios-de-medicion","title":"Tarea 5: Ejercicios de medici\u00f3n","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <p>Periodo promedio y tolerancia.</p> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS. Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#evidencia","title":"Evidencia","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_6","title":"C\u00f3digo","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN PICO_DEFAULT_LED_PIN\nstatic const int BLINK_MS = 1000;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#analisis","title":"An\u00e1lisis","text":"<p>Al generar una se\u00f1al por medio de temporizadores, al momento de medirla en el osciloscopio se pudo observar el peque\u00f1o delay que se genera al usar este modo.</p> <p>Se configur\u00f3 el osciloscopio con un voltaje de 1V, para as\u00ed poder observar correctamente las se\u00f1ales. El tiempo de parpadeo era de 1 segundo y en el osciloscopio se obtuvo un ciclo de 1.001 s. Es decir que tiene un delay de 1 milisegundo</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <p>Usa rearme acumulativo.</p> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo:</p> <p>Periodo promedio y desviaci\u00f3n respecto al nominal.</p> <p>Jitter pico-a-pico y/o RMS. Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#evidencia_1","title":"Evidencia","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_7","title":"C\u00f3digo","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       PICO_DEFAULT_LED_PIN\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 1000000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_1","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#comparacion","title":"Comparaci\u00f3n","text":"<p>Al comparar los dos modos, se encontr\u00f3 una diferencia entre el modo \u00b5s vs ciclos. El modo ciclos es m\u00e1s preciso y no genera ning\u00fan delay perceptible en el osciloscopio a diferncia del modo \u00b5s que tiene una diferencia de 1 ms.</p> <p>Con esta informaci\u00f3n se puede concluir que para tener un timer preciso el uso de los ciclos es el ideal y el mejor para implementar en futuros proyectos, ya que genera un timer \u00f3ptimo y sin delays. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-6-ejercicios-de-programacion","title":"Tarea 6: Ejercicios de programaci\u00f3n","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#ejercicio-1-cuatro-alarmas-cuatro-leds-a-distintas-frecuencias","title":"Ejercicio 1: Cuatro alarmas / cuatro LEDs a distintas frecuencias","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_8","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     0\n#define LED1_PIN     1\n#define LED2_PIN     3\n#define LED3_PIN     4\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 200000u;\nstatic const uint32_t INTERVALO1_US = 400000u;\nstatic const uint32_t INTERVALO2_US = 600000u;\nstatic const uint32_t INTERVALO3_US = 800000u;\n\n// ISR \u00daNICA para el TIMER\nstatic void on_timer_irq(void) {\n    uint32_t status = timer_hw-&gt;intr;  \n    timer_hw-&gt;intr = status;\n\n    if (status &amp; (1u &lt;&lt; ALARM0_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n        next0_us += INTERVALO0_US;\n        timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM1_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n        next1_us += INTERVALO1_US;\n        timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM2_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n        next2_us += INTERVALO2_US;\n        timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM3_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n        next3_us += INTERVALO3_US;\n        timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n    }\n}\n\nint main() {\n    gpio_init(LED0_PIN); gpio_set_dir(LED0_PIN, GPIO_OUT); gpio_put(LED0_PIN, 0);\n    gpio_init(LED1_PIN); gpio_set_dir(LED1_PIN, GPIO_OUT); gpio_put(LED1_PIN, 0);\n    gpio_init(LED2_PIN); gpio_set_dir(LED2_PIN, GPIO_OUT); gpio_put(LED2_PIN, 0);\n    gpio_init(LED3_PIN); gpio_set_dir(LED3_PIN, GPIO_OUT); gpio_put(LED3_PIN, 0);\n\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    hw_clear_bits(&amp;timer_hw-&gt;intr,\n                  (1u &lt;&lt; ALARM0_NUM) |\n                  (1u &lt;&lt; ALARM1_NUM) |\n                  (1u &lt;&lt; ALARM2_NUM) |\n                  (1u &lt;&lt; ALARM3_NUM));\n\n    int irq_num = timer_hardware_alarm_get_irq_num(timer_hw, 0);\n    irq_set_exclusive_handler(irq_num, on_timer_irq);\n\n    hw_set_bits(&amp;timer_hw-&gt;inte,\n                (1u &lt;&lt; ALARM0_NUM) |\n                (1u &lt;&lt; ALARM1_NUM) |\n                (1u &lt;&lt; ALARM2_NUM) |\n                (1u &lt;&lt; ALARM3_NUM));\n\n    irq_set_enabled(irq_num, true);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquema_1","title":"Esquema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_6","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#ejercicio-2","title":"Ejercicio 2","text":"<p>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_9","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Leds 5\n#define Delayminimo 100\n#define Delaymaximo 1000\n#define Delay 100\n\nconst uint Boton1 = 14;     \nconst uint Boton2 = 15;  \nconst uint Botonmasvel = 13;  \nconst uint Botonmenosvel = 12;\nconst uint LEDS[Leds] = {0, 1, 2, 3, 4};\nconst uint LedP1 = 6;    // LED indicador derecha\nconst uint LedP2 = 8;    // LED indicador izquierda\n\nvolatile bool Reb1 = false;\nvolatile bool Reb2 = false;\nvolatile bool Subiovel = false;\nvolatile bool Bajovel = false;\n\nvoid button_isr(uint gpio, uint32_t events) {\n    if (gpio == Boton1) Reb1 = true;\n    else if (gpio == Boton2) Reb2 = true;\n    else if (gpio == Botonmasvel) Subiovel = true;\n    else if (gpio == Botonmenosvel) Bajovel = true;\n}\n\nvoid score_point(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main() {\n    // Anotaci\u00f3n de puntos\n    gpio_init(LedP1); gpio_set_dir(LedP1, true);\n    gpio_init(LedP2); gpio_set_dir(LedP2, true);\n\n\n    gpio_init(Boton1); gpio_set_dir(Boton1, false); gpio_pull_up(Boton1);\n    gpio_set_irq_enabled_with_callback(Boton1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(Boton2); gpio_set_dir(Boton2, false); gpio_pull_up(Boton2);\n    gpio_set_irq_enabled(Boton2, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmasvel); gpio_set_dir(Botonmasvel, false); gpio_pull_up(Botonmasvel);\n    gpio_set_irq_enabled(Botonmasvel, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmenosvel); gpio_set_dir(Botonmenosvel, false); gpio_pull_up(Botonmenosvel);\n    gpio_set_irq_enabled(Botonmenosvel, GPIO_IRQ_EDGE_FALL, true);\n\n    // LEDs del juego\n    for (int i = 0; i &lt; Leds; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int current_led = Leds / 2;\n    int direction = 0;\n    bool game_started = false;\n    int delay_ms = 400; // velocidad inicial\n\n    gpio_put(LEDS[current_led], 1);\n\n    while (true) {\n        // Ajustar velocidad\n        if (Subiovel) {\n            if (delay_ms &gt; Delayminimo) delay_ms -= Delay;\n            Subiovel = false;\n        }\n        if (Bajovel) {\n            if (delay_ms &lt; Delaymaximo) delay_ms += Delay;\n            Bajovel = false;\n        }\n\n\n        if (!game_started) {\n            if (Reb1) { direction = 1; game_started = true; Reb1 = false; gpio_put(LEDS[current_led], 0);}\n            else if (Reb2) { direction = -1; game_started = true; Reb2 = false; gpio_put(LEDS[current_led], 0);}\n            else continue;\n        }\n\n        gpio_put(LEDS[current_led], 1);\n        sleep_ms(delay_ms);  //el delay depende del bot\u00f3n\n        gpio_put(LEDS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == -1) {\n            if (Reb1) { direction = 1; current_led = 0; Reb1 = false; }\n            else { score_point(LedP1); current_led = Leds/2; direction = 1; }\n        }\n        if (current_led == Leds) {\n            if (Reb2) { direction = -1; current_led = Leds - 1; Reb2 = false; }\n            else { score_point(LedP2); current_led = Leds/2; direction = -1; }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquema_2","title":"Esquema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_7","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#examen-1-simon-dice","title":"EXAMEN 1: Sim\u00f3n dice","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> <p>La persona jugadora debe repetir la secuencia con 4 botones.</p> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> <p>Reglas del juego (obligatorias) Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_10","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n#define Rondas 15\n#define Parpadeo 400\n#define Pausa 250\n#define Debounce 50\n\n#define LED0 0\n#define LED1 1\n#define LED2 3\n#define LED3 4\n\n#define BTN0 27\n#define BTN1 28\n#define BTN2 14\n#define BTN3 15\n\n#define SegmentoA  16\n#define SegmentoB  17\n#define SegmentoC  18\n#define SegmentoD 26\n#define SegmentoDp  20\n#define SegmentoE  21\n#define SegmentoF  22\n#define SegmentoG  2\n\n// arrays de pines para recorrer\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\nconst uint Botones[4] = {BTN0, BTN1, BTN2, BTN3};\nconst uint Segmentos[8] = {SegmentoA, SegmentoB, SegmentoC, SegmentoDp, SegmentoE, SegmentoF, SegmentoG, SegmentoD};\n\n//\u00c1nodo com\u00fan, 0=1, 1=0\nconst bool MapaDisplay[16][8] = {\n    {0,0,0,0,0,0,1,1}, // 0\n    {1,0,0,1,1,1,1,1}, // 1\n    {0,0,1,0,0,1,0,1}, // 2\n    {0,0,0,0,1,1,0,1}, // 3\n    {1,0,0,1,1,0,0,1}, // 4\n    {0,1,0,0,1,0,0,1}, // 5\n    {0,1,0,0,0,0,0,1}, // 6\n    {0,0,0,1,1,1,1,1}, // 7\n    {0,0,0,0,0,0,0,1}, // 8\n    {0,0,0,0,1,0,0,1}, // 9\n    {0,0,0,1,0,0,0,1}, // A\n    {1,1,0,0,0,0,0,1}, // b\n    {0,1,1,0,0,0,1,1}, // C\n    {1,0,0,0,0,1,0,1}, // d\n    {0,1,1,0,0,0,0,1}, // E\n    {0,1,1,1,0,0,0,1}  // F\n};\n\nuint8_t Sequencia[Rondas];\nint Num_sequencia = 0;\n\nvoid MuestraDisplay(uint8_t n) {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_put(Segmentos[i], MapaDisplay[n &amp; 0xF][i]);\n    }\n}\n\nvoid Blink(uint8_t iL, uint32_t ms) {\n    gpio_put(LEDS[iL], 1);\n    sleep_ms(ms);\n    gpio_put(LEDS[iL], 0);\n}\n\nint PresionaBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) { \n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); \n                return i;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid EsperarBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) {\n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); // espera a quitar el bot\u00f3n presionado\n                return;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid IniciarLeds() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n}\n\nvoid IniciarBotones() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(Botones[i]);\n        gpio_set_dir(Botones[i], false);\n        gpio_pull_up(Botones[i]);\n    }\n}\n\nvoid IniciarDisplay() {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_init(Segmentos[i]);\n        gpio_set_dir(Segmentos[i], true);\n    }\n}\n\n// Reproduce la secuencia actual\nvoid ReproducirSecuencia(int lim) {\n    sleep_ms(300);\n    for (int i = 0; i &lt; lim; i++) {\n        Blink(Sequencia[i], Parpadeo);\n        sleep_ms(Pausa);\n    }\n}\n\n// Game Over\nvoid GameOver(uint8_t score) {\n    MuestraDisplay(score &gt; 15 ? 15 : score);\n\n\n    for (int j = 0; j &lt; 6; j++) {\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 1);\n        sleep_ms(120);\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 0);\n        sleep_ms(120);\n    }\n\n\n    EsperarBoton();\n\n    Num_sequencia = 0;\n    MuestraDisplay(0);\n}\n\n// Genera un nuevo color aleatorio y lo agrega a la secuencia\nvoid SiguienteRonda() {\n    Sequencia[Num_sequencia++] = rand() &amp; 0x3;\n    if (Num_sequencia &gt; Rondas) Num_sequencia = Rondas;\n}\n\nbool PresionarSecuencia() { //La funci\u00f3n que tiene que hacer el jugador f\u00edsicamente\n    for (int i = 0; i &lt; Num_sequencia; i++) {\n        int presionar = PresionaBoton();\n        Blink(presionar, 120);\n        if (presionar != Sequencia[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main() {\n    stdio_init_all();\n    IniciarLeds();\n    IniciarBotones();\n    IniciarDisplay();\n\n    // Aleatoriedad: ADC + tiempo\n    adc_init();\n    adc_gpio_init(26);\n    adc_select_input(0);\n    uint16_t noise = adc_read();\n    srand(to_us_since_boot(get_absolute_time()) ^ noise);\n\n    MuestraDisplay(0);\n\n    while (1) {\n\n        EsperarBoton();\n\n        while (1) {\n            SiguienteRonda();\n            MuestraDisplay(Num_sequencia);\n            sleep_ms(400);\n            ReproducirSecuencia(Num_sequencia);\n\n            bool Correcto = PresionarSecuencia();\n\n            if (!Correcto) {\n                GameOver(Num_sequencia - 1);\n                break; // reinicia juego\n            }\n\n            if (Num_sequencia &gt;= Rondas) {\n                GameOver(Rondas);\n                break; // reinicia juego\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_2","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_8","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-7","title":"Tarea 7","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#71-control-de-duty-cycle-motor-dc","title":"7.1: Control de Duty Cycle \u2014 Motor DC","text":"<p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_11","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// Pines puente H TB6612\n#define PWMA   0   \n#define AIN1   1   \n#define AIN2   2   \n#define STBY   3   \n\n#define BTN_LOW   16\n#define BTN_MED   17\n#define BTN_HIGH  18\n\n#define F_PWM_HZ 2000   \n#define TOP 1023       \n\n#define DUTY_LOW   (TOP * 30 / 100)   // 30%\n#define DUTY_MED   (TOP * 60 / 100)   // 60%\n#define DUTY_HIGH  (TOP * 90 / 100)   // 90%\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(AIN1);\n    gpio_set_dir(AIN1, GPIO_OUT);\n    gpio_put(AIN1, 1);\n\n    gpio_init(AIN2);\n    gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_put(AIN2, 0);\n\n    gpio_init(STBY);\n    gpio_set_dir(STBY, GPIO_OUT);\n    gpio_put(STBY, 1);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    uint chan  = pwm_gpio_to_channel(PWMA);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    gpio_init(BTN_LOW);\n    gpio_set_dir(BTN_LOW, GPIO_IN);\n    gpio_pull_up(BTN_LOW);\n\n    gpio_init(BTN_HIGH);\n    gpio_set_dir(BTN_HIGH, GPIO_IN);\n    gpio_pull_up(BTN_HIGH);\n\n    while (1) {\n        if (!gpio_get(BTN_LOW)) {\n            pwm_set_chan_level(slice, chan, DUTY_LOW);\n        }\n\n        else if (!gpio_get(BTN_HIGH)) {\n            pwm_set_chan_level(slice, chan, DUTY_HIGH);\n        }\n        sleep_ms(100); \n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_3","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_9","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#72-control-de-frecuencia-cancion-con-buzzer","title":"7.2: Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":"<p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_12","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdint.h&gt;\n\n\n#define Buzzer 2\n#define TEMPO 200   // BPM\n\n#define DO3   34\n#define RE3   61\n#define MI3   68\n#define FA3   78\n#define SOL3  82\n#define SOLs3 111\n#define LA3   123\n#define SI3   151\n\n#define DO4   220\n#define DOs4  184\n#define RE4   250\n#define REs4  218\n#define MI4   282  \n#define FA4   300\n#define FAs4  277\n#define SOLb4 277\n#define SOL4  330\n#define SOLs4 350\n#define LAb4  350\n#define LA4   370\n#define LAs4  392\n#define SIb4  392\n#define SI4   420\n\n#define DO5   442\n#define DOs5  457\n#define RE5   495\n#define REs5  523\n#define MIb5  523\n#define MI5   560\n#define FA5   603\n#define FAs5  630\n#define SOL5  660\n#define SOLs5 735\n#define LA5   755\n#define LAs5  835\n#define SI5   845\n\n#define DO6   880\n\n#define SILENCIO 0\n\n\n// FIGURAS\n#define REDONDA   4.0f\n#define BLANCAP   3.0f\n#define BLANCA    2.0f\n#define NEGRA     1.0f\n#define CORCHEA   0.5f\n#define DCORCHEA  0.25f\n\nconst float reloj = 125000000.0f; // reloj 125 MHz\nuint slice_num;\nuint chan_num;\n\n// ---------- UTIL ----------\nstatic inline int duracion_ms(float figura) {\n    float negra_ms = 60000.0f / (float)TEMPO;\n    return (int)(figura * negra_ms + 0.5f);\n}\n\nvoid iniciar_pwm(uint gpio) {\n    gpio_set_function(gpio, GPIO_FUNC_PWM);\n    slice_num = pwm_gpio_to_slice_num(gpio);\n    chan_num  = pwm_gpio_to_channel(gpio);\n    pwm_set_enabled(slice_num, true);\n}\n\nvoid reproducir_nota(int frecuencia, float figura) {\n    if (frecuencia == SILENCIO) {\n        pwm_set_chan_level(slice_num, chan_num, 0);\n        sleep_ms(duracion_ms(figura));\n        return;\n    }\n\n    uint32_t wrap = 0;\n    float clkdiv = 1.0f;\n    for (int d = 1; d &lt;= 256; d++) {\n        float wrapf = reloj / ((float)d * (float)frecuencia) - 1.0f;\n        if (wrapf &gt;= 1.0f &amp;&amp; wrapf &lt;= 65535.0f) {\n            clkdiv = (float)d;\n            wrap = (uint32_t)(wrapf + 0.5f);\n            break;\n        }\n    }\n\n    if (wrap == 0) {\n        wrap = 65535;\n        clkdiv = reloj / ((wrap + 1) * (float)frecuencia);\n        if (clkdiv &lt; 1.0f) clkdiv = 1.0f;\n        if (clkdiv &gt; 256.0f) clkdiv = 256.0f;\n    }\n\n    pwm_set_clkdiv(slice_num, clkdiv);\n    pwm_set_wrap(slice_num, wrap);\n    pwm_set_chan_level(slice_num, chan_num, wrap / 2);\n\n    sleep_ms(duracion_ms(figura));\n\n    pwm_set_chan_level(slice_num, chan_num, 0);\n    sleep_ms(30);\n}\n\n\ntypedef struct {\n    int nota;\n    float figura;\n} Nota_t;\n\n\nNota_t escala[] = {\n    {MIb5, NEGRA},{SILENCIO, BLANCA}, {RE4, NEGRA}, {SILENCIO, BLANCA}, {MI4, NEGRA}, {SILENCIO, BLANCA}, {FA4, NEGRA}, {SILENCIO, BLANCA}, {SOL4, NEGRA}, {SILENCIO, BLANCA}, {LA4, NEGRA}, {SILENCIO, BLANCA}, {SI4, NEGRA}, {SILENCIO,BLANCA},\n {DO5, NEGRA}, {SILENCIO, BLANCA}, {RE5, NEGRA}, {SILENCIO, BLANCA}, {MI5, NEGRA}, {SILENCIO, BLANCA}, {FA5, NEGRA}, {SILENCIO, BLANCA}, {SOL5, NEGRA}, {SILENCIO, BLANCA}, {LA5, NEGRA}, {SILENCIO, BLANCA}, {SI5, NEGRA}, {SILENCIO,BLANCA}, {DO6,NEGRA}\n};\n\n\nNota_t cumple[] = {\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {FA4, NEGRA}, {MI4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {DO5, CORCHEA}, {LA4, NEGRA}, {FA4, NEGRA}, {MI4, NEGRA}, {RE4, 2.0f},\n    {SI4, NEGRA}, {SI4, CORCHEA}, {LA4, CORCHEA}, {FA4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f}\n};\n\nNota_t mario[] = { {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, NEGRA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA},\n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {DO5, CORCHEA}, {DO5, CORCHEA},  {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {MI5, NEGRA}, {SILENCIO, REDONDA}, \n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, BLANCA},\n{DO5, BLANCA}, {SILENCIO, DCORCHEA}, {SOL4, BLANCA}, {SILENCIO, DCORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SILENCIO, DCORCHEA}, {SI4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {FA4, CORCHEA}, {SOL4, BLANCAP}, {SILENCIO, REDONDA}, {SILENCIO, REDONDA}\n};\n\n\n// ---------- Funci\u00f3n gen\u00e9rica ----------\nvoid reproducir_melodia(Nota_t *melodia, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        reproducir_nota(melodia[i].nota, melodia[i].figura);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    iniciar_pwm(Buzzer);\n\n    Nota_t *melodia = mario;  // seleccionar la funci\u00f3n de melod\u00eda, cambiar mario por la que sea\n    int n = sizeof(mario) / sizeof(mario[0]);\n\n\n    while (1) {\n        reproducir_melodia(melodia, n);\n        sleep_ms(500); // pausa para el bucle de la melod\u00eda\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_4","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_10","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#73-generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"7.3: Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_13","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWMA 0       \n#define FS   2000   \n#define F_SENO 60    \n#define TOP   1023   \n\n#define ALARM0_NUM 0\n#define ALARM0_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n\n#define TABLA_T (FS / F_SENO)\n\nuint16_t tabla_sen[TABLA_T];\nvolatile int x = 0;\n\nvoid alarm0_isr() {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    // Actualizar PWM con el siguiente valor del seno\n    pwm_set_gpio_level(PWMA, tabla_sen[x]);\n    x = (x + 1) % TABLA_T;\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n}\n\nint main() {\n    stdio_init_all();\n\n    // === Generar tabla de seno ===\n    for (int i = 0; i &lt; TABLA_T; i++) {\n        float ang = 2 * M_PI * i / TABLA_T;\n        float s = (sinf(ang) + 1.0f) / 2.0f;  // Normalizado 0\u20131\n        tabla_sen[i] = (uint16_t)(s * TOP);\n    }\n\n    // === Configurar PWM en PWMA ===\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    float f_clk = 125000000.0f; // clock base 125 MHz\n    float div = f_clk / (FS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    irq_set_exclusive_handler(ALARM0_IRQ, alarm0_isr);\n    irq_set_enabled(ALARM0_IRQ, true);\n\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n\n    while (1) {\n        tight_loop_contents(); \n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_5","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#evidencia_2","title":"Evidencia","text":"<p>Se\u00f1al de entrada del PWM a 2kHz  Se\u00f1al de salida del filtro a 60Hz </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-8-uart","title":"Tarea 8 UART","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#1-por-medio-de-comunicacion-entre-dos-pico-2-lograr-accionar-leds-con-botones","title":"1 - Por medio de comunicaci\u00f3n entre dos Pico 2 , lograr accionar leds con botones.","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-echo","title":"C\u00f3digo echo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-receptor","title":"C\u00f3digo receptor","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_11","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#2-por-medio-de-la-consola-lograr-prender-leds-conectados-a-las-pico-2","title":"2 - Por medio de la consola lograr prender leds conectados a las Pico 2.","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-con-1-caracter","title":"C\u00f3digo con 1 caracter","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define BTN 3\n#define LED 2\n\n\n\nint main() {\n\n\n    stdio_init_all();\n\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(BTN);\n    gpio_set_dir(BTN, false);\n    gpio_pull_up(BTN);\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n            if (c == '1') {\n                gpio_put(LED, 1);  \n                printf(\"LED encendido!\\n\");\n            } \n\n            else {\n                gpio_put(LED, 0);  \n\n            }\n         }\n\n        bool pressed = !gpio_get(BTN);  \n        if (pressed) {\n            printf(\"Bot\u00f3n presionado!\\n\");\n            uart_putc(UART_ID, '1');\n            sleep_ms(300); \n\n\n        }\n         sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-con-un-string","title":"C\u00f3digo con un string","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all(); // Inicializa USB serial\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico listo] Comunicaci\u00f3n UART iniciando...\\n\");\n\n    // Inicializa UART antes de asignar pines\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // Configuraci\u00f3n del LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string mensaje_usb = \"\";\n    string mensaje_uart = \"\";\n\n    while (true) {\n        //Escritura mensaje\n        int ch = getchar_timeout_us(0); // no bloqueante\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    uart_puts(UART_ID, (mensaje_usb + \"\\n\").c_str());\n                    printf(\"Mensaje enviado: %s\\n\", mensaje_usb.c_str());\n                    mensaje_usb = \"\";\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        //Lectura en UART\n        while (uart_is_readable(UART_ID)) {\n            char ch_uart = uart_getc(UART_ID);\n\n            if (ch_uart == '\\n' || ch_uart == '\\r') {\n                if (!mensaje_uart.empty()) {\n                    printf(\"Mensaje recibido: %s\\n\", mensaje_uart.c_str());\n\n                    // Comparar informaci\u00f3n\n                    if (mensaje_uart == \"on\" || mensaje_uart == \"ON\") {\n                        gpio_put(LED_PIN, 1);\n                        printf(\"LED encendido\\n\");\n                    } else if (mensaje_uart == \"off\" || mensaje_uart == \"OFF\") {\n                        gpio_put(LED_PIN, 0);\n                        printf(\"LED apagado\\n\");\n                    } else {\n                        printf(\"Comando desconocido.\\n\");\n                    }\n\n                    mensaje_uart = \"\";\n                }\n            } else {\n                mensaje_uart += ch_uart;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_12","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#3-elaborar-un-hanshake","title":"3 - Elaborar un Hanshake.","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-maestro","title":"C\u00f3digo maestro","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico A listo] Escribe 'conectar' para iniciar handshake.\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string usb_msg = \"\";\n    string uart_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer comandos desde USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        // Leer mensajes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"[Recibido]: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"ok\") {\n                            printf(\"Pico B respondi\u00f3 OK.\\n\");\n                        } else if (uart_msg == \"conectado\") {\n                            printf(\"Conexi\u00f3n establecida \\n\");\n                            conectado = true;\n                        } else {\n                            printf(\"[Error] Mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"[LED] Encendido (por comando remoto)\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"[LED] Apagado (por comando remoto)\\n\");\n                        } else {\n                            printf(\"Error: Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-esclavo","title":"C\u00f3digo esclavo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\nPico B listo, Esperando handshake desde el otro dispositivo...\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string uart_msg = \"\";\n    string usb_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer mensajes entrantes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"Recibido: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"conectar\") {\n                            uart_puts(UART_ID, \"ok\\n\");\n                            sleep_ms(300);\n                            uart_puts(UART_ID, \"conectado\\n\");\n                            conectado = true;\n                            printf(\"Conexi\u00f3n establecida\\n\");\n                        } else {\n                            uart_puts(UART_ID, \"error\\n\");\n                            printf(\"Error, mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"LED encendido\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"LED apagado\\n\");\n                        } else {\n                            printf(\"[Error] Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_13","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#examen-2","title":"Examen 2","text":"<p>Control de Servomotores con comandos Hardware m\u00ednimo 1 \u00d7 servomotor en un pin PWM (50 Hz).</p> <p>3 \u00d7 botones:</p> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> <p>Pi pico 2</p> <p>Modos de operaci\u00f3n 1) Modo Entrenamiento Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> <p>Borrar (alias: clear, borrar)</p> <p>Sintaxis: Borrar</p> <p>Efecto: elimina la lista completa de posiciones.</p> <p>Respuesta: OK.</p> <p>Escribir (alias: write, escribir)</p> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> <p>vi son enteros en 0\u2013180.</p> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> <p>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</p> <p>2) Modo Continuo Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> <p>3) Modo Step BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> <p>En cada cambio de posici\u00f3n:</p> <p>mover el servo a la posici\u00f3n seleccionada;</p> <p>imprimir posX: V.</p> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> <p>INFO IMPORTANTE: El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 2\n#define BTN_ATRAS 14\n#define BTN_ADELANTE 13\n#define BTN_MODE 16\n#define UARTID uart0\n#define BAUDIOS 115200\n#define TX 0\n#define RX 1\n#define MOVIMIENTOS 10\n#define TOP 20000\n\nint posiciones[MOVIMIENTOS] = {0};\nint num_pos = 0;\nint modo = 1, idx = 0;\nvolatile bool cambio_modo = false;\n\n//FUNCIONES \ninline int angle_to_pulse(int a){\n    return 450+(a*1200)/180;\n}\n//solo llama esa parte del codigo para llamar lo de adentro \n//de angle to pulse del servo\ninline void set_servo(uint s,uint c,int a){\n    pwm_set_chan_level(s,c,angle_to_pulse(a));\n}\n\nvoid borrar_lista(){\n    for(int i=0;i&lt;MOVIMIENTOS;i++) \n    posiciones[i]=0;\n    num_pos=0;\n}\nbool lista_vacia(){\n    if(num_pos==0) \n        return true;\n    for(int i=0;i&lt;num_pos;i++) \n        if(posiciones[i]!=0)\n            return false;\n    return true;\n}\nvoid imprimir_lista(){\n    printf(\"Lista actual: \");\n    for(int i=0;i&lt;MOVIMIENTOS;i++){\n        printf(\"%d\",posiciones[i]); if(i&lt;MOVIMIENTOS-1)printf(\", \"); \n    }\n    printf(\"\\n\");\n}\n//pasa todo a minusculas\nvoid str_tolower(string &amp;s){for(auto &amp;c:s)c=tolower(c);}\n\n//ISR\nvoid cambio_isr(uint gpio,uint32_t events){cambio_modo=true;}\n\nint main(){\n    stdio_init_all();\n    sleep_ms(1500);\n\n    uart_init(UARTID,BAUDIOS);\n    gpio_set_function(TX,GPIO_FUNC_UART);\n    gpio_set_function(RX,GPIO_FUNC_UART);\n    uart_set_format(UARTID,8,1,UART_PARITY_NONE);\n\n    // SERVO\n    gpio_set_function(SERVO_PIN,GPIO_FUNC_PWM);\n    uint slice=pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan=pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_clkdiv(slice,150.0f); \n    pwm_set_wrap(slice,TOP);\n    pwm_set_enabled(slice,true);\n\n    gpio_init(BTN_ATRAS);\n    gpio_set_dir(BTN_ATRAS,false);\n    gpio_pull_up(BTN_ATRAS);\n    gpio_init(BTN_ADELANTE);\n    gpio_set_dir(BTN_ADELANTE,false);\n    gpio_pull_up(BTN_ADELANTE);\n    gpio_init(BTN_MODE);\n    gpio_set_dir(BTN_MODE,false); \n    gpio_pull_up(BTN_MODE);\n    gpio_set_irq_enabled_with_callback(BTN_MODE,GPIO_IRQ_EDGE_FALL,true,&amp;cambio_isr);\n\n    printf(\"\\n=== MODO 1: ENTRENAMIENTO ===\\nComandos: escribir / borrar\\n\");\n\n    string input;\n    bool tope_adelante=1,tope_atras=1;\n    while(true){\n        //CAMBIO DE MODO\n        if(cambio_modo){\n            cambio_modo=false;\n            modo=(modo%3)+1;\n            idx=0;\n            printf(\"\\n=== CAMBIO A MODO %d ===\\n\",modo);\n\n            if(!lista_vacia()){\n                set_servo(slice,chan,posiciones[0]);\n                sleep_ms(500);\n            }\n            if(modo==1) printf(\"Modo entrenamiento: escribir / borrar\\n\");\n            if(modo==2) printf(\"Modo repetici\u00f3n autom\u00e1tica.\\n\");\n            if(modo==3) printf(\"Modo paso a paso con botones.\\n\");\n        }\n        //MODO 1 \n        if(modo==1){\n            int ch=getchar_timeout_us(0);\n            //uart de clase para controlar la consola\n            if(ch!=PICO_ERROR_TIMEOUT){\n                if(ch=='\\r'||ch=='\\n'){\n                    if(!input.empty()){\n                        string cmd=input; \n                        str_tolower(cmd);\n                        if(cmd==\"borrar\"||cmd==\"clear\"){\n                            borrar_lista();printf(\"OK.\\n\");\n                            imprimir_lista();\n                        }\n                        else if(cmd.find(\"escribir\")==0||cmd.find(\"write\")==0){\n                            printf(\"\u00bfCu\u00e1ntos valores (1\u201310)?: \");\n                            fflush(stdout);\n                            string n_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; n_str+=(char)c;\n                                }\n                            }\n                            //string to int\n                            int n=stoi(n_str);\n                            if(n&lt;1||n&gt;MOVIMIENTOS){\n                                printf(\"Fuera de rango.\\n\");\n                                input.clear();\n                                continue;\n                            }\n                            printf(\"Ingrese %d valores (0\u2013180) separados por espacios:\\n\",n);\n                            //fuerza la salida del texto en el monitor serial\n                            fflush(stdout);\n                            string val_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; val_str+=(char)c;\n                                }\n                            }\n                            borrar_lista();\n                            int i=0; \n                            size_t pos=0;\n                            while(i&lt;n &amp;&amp; pos&lt;val_str.size()){\n                                //para que no tenga signo y siempre sea +\n                                size_t e=val_str.find(' ',pos);\n                                int v=stoi(val_str.substr(pos,e-pos));\n                                if(v&lt;0||v&gt;180){\n                                    printf(\"Valor fuera de rango.\\n\");break;\n                                }\n                                posiciones[i++]=v;\n                                if(e==string::npos)break; pos=e+1;\n                            }\n                            num_pos=i;\n                            printf(\"OK.\\n\");\n                            imprimir_lista();\n                        }\n                        else printf(\"Comando no reconocido.\\n\");\n                        input.clear();\n                    }\n                } else input+=(char)ch; //agregar el caracter al string input\n            }\n        }\n\n        //MODO 2\n        else if(modo==2){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");sleep_ms(1000);\n            }\n            else{\n                for(int i=0;i&lt;num_pos;i++){\n                    if(cambio_modo)break;\n                    set_servo(slice,chan,posiciones[i]);\n                    sleep_ms(1500);\n                }\n            }\n        }\n\n        //MODO 3\n        else if(modo==3){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");\n                sleep_ms(1000);\n            }\n            else{\n                set_servo(slice,chan,posiciones[idx]);\n                bool adelante=gpio_get(BTN_ADELANTE);\n                bool atras=gpio_get(BTN_ATRAS);\n                if(!adelante &amp;&amp; tope_adelante){ \n                    if(idx&lt;num_pos-1 &amp;&amp; posiciones[idx+1]!=0){\n                        idx++;\n                        set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Avance a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Fin de secuencia.\\n\");\n                }\n                if(!atras &amp;&amp; tope_atras){\n                    if(idx&gt;0){\n                        idx--;\n                        set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Retroceso a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Inicio de secuencia.\\n\");\n                }\n                tope_adelante=adelante; \n                tope_atras=atras;\n                sleep_ms(100);\n            }\n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_14","title":"Video","text":""}]}