{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Embeded_Systems_2/Assignments/","title":"Assignments","text":""},{"location":"Embeded_Systems_2/Assignments/#class-act1","title":"Class Act1","text":""},{"location":"Embeded_Systems_2/Assignments/#exercise-objective","title":"Exercise Objective","text":"<p>The goal of this exercise is to train you to identify logical FreeRTOS tasks from system behavior, even when no RTOS code is shown.</p> <p>You should focus on:</p> <ul> <li>Timing requirements</li> <li>Blocking behavior</li> <li>Safety and criticality</li> <li>Independent execution flows</li> </ul> <p>Think in terms of \"what must happen independently\", not functions or lines of code.</p>"},{"location":"Embeded_Systems_2/Assignments/#system-description","title":"System Description","text":"<p>You are given the following description of an embedded system:</p>"},{"location":"Embeded_Systems_2/Assignments/#the-system","title":"The system:","text":"<ul> <li>Reads a temperature sensor every 50 ms</li> <li>Sends sensor data via Wi-Fi every 2 seconds</li> <li>Monitors an emergency button continuously</li> <li>Blinks a status LED at 1 Hz</li> <li>Stores error messages when failures occur</li> </ul> Task name Trigger Periodic or Event-based Is time critical? Can it Block safely? What if delayed Priority Temperature sensor 50ms Timer Periodic YES NO Reading error Medium WiFi 2s timer Periodic NO NO Missing data Medium Emergency Button Press button Event YES NO An accident High LED Status 2s timer Periodic NO YES Just a delay of the status Low Error Message Error Event NO YES We store it later Low"},{"location":"Embeded_Systems_2/Assignments/#rtos-basics-with-esp-idf-lab","title":"RTOS Basics with ESP-IDF LAB","text":""},{"location":"Embeded_Systems_2/Assignments/#lab-1","title":"Lab 1","text":""},{"location":"Embeded_Systems_2/Assignments/#goal","title":"Goal","text":"<p>Create two tasks:</p> <p>blink_task: toggles an LED every 300 ms</p> <p>hello_task: prints a message every 1 second</p>"},{"location":"Embeded_Systems_2/Assignments/#what-to-watch-for","title":"What to watch for","text":"<ul> <li>Both tasks run (interleave).</li> <li>Changing priority can change which task runs \u201cmore\u201d or \u201cfirst\u201d.</li> <li>If you remove a delay from a task, it may hog the CPU.</li> </ul>"},{"location":"Embeded_Systems_2/Assignments/#code-lab-1","title":"Code Lab 1","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Embeded_Systems_2/Assignments/#excersises","title":"Excersises","text":"<ol> <li>Priority experiment: change hello_task priority from 5 to 2.</li> <li>Does behavior change? Why might it (or might it not)?</li> <li>Starvation demo: temporarily remove vTaskDelay(...) from hello_task.</li> <li>What happens to blinking?</li> <li>Put the delay back and explain in one sentence why blocking helps.</li> </ol>"},{"location":"Embeded_Systems_2/Assignments/#answers","title":"Answers","text":"<ol> <li> <p>Priority experiment (hello_task priority 5 \u2192 2): The blink_task runs more consistently, while hello_task still runs but may execute less frequently.</p> </li> <li> <p>Does behavior change? Why might it (or might it not)? The behavior changes slightly because a higher-priority task is scheduled first, but both tasks still run since they block using delays.</p> </li> <li> <p>Starvation demo (remove vTaskDelay from hello_task): hello_task runs continuously and at some point the CPU crashes.</p> </li> <li> <p>What happens to blinking? The LED stops blinking or becomes very irregular because blink_task is starved of CPU time.</p> </li> <li> <p>Why blocking helps (one sentence): Blocking with delays allows to switch tasks fairly and prevents one task from monopolizing the CPU.</p> </li> </ol>"},{"location":"Embeded_Systems_2/Assignments/#lab-2","title":"Lab 2","text":""},{"location":"Embeded_Systems_2/Assignments/#goal_1","title":"Goal","text":"<p>Use a queue to pass integers from a producer task to a consumer task.</p> <p>Why it matters: - Queues are a clean way to pass data without sharing global variables.</p>"},{"location":"Embeded_Systems_2/Assignments/#code-lab-2","title":"Code Lab 2","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Embeded_Systems_2/Assignments/#excersises_1","title":"Excersises","text":"<ol> <li>Make the producer faster: change producer delay 200ms \u2192 20ms.</li> <li>When do you see \u201cQueue full\u201d?</li> <li>Increase the queue length 5 \u2192 20.</li> <li>What changes?</li> <li>Make the consumer \u201cslow\u201d: after a successful receive, add:</li> <li>What pattern is happening now (buffering / backlog)?</li> </ol>"},{"location":"Embeded_Systems_2/Assignments/#answers_1","title":"Answers","text":"<ol> <li> <p>Make the producer faster (200ms \u2192 20ms): The producer generates data much faster than the consumer can process it.</p> </li> <li> <p>When do you see \u201cQueue full\u201d?: Right now it never appears, but it would appear if the producer fills the queue faster than the consumer removes items from it.</p> </li> <li> <p>Increase the queue length (5 \u2192 20): The queue can store more items before becoming full.</p> </li> <li> <p>What changes?: Queue full never appears or takes a lot of time to appear.</p> </li> <li> <p>Make the consumer \u201cslow\u201d: After adding a delay, the consumer processes items more slowly than they are produced.</p> </li> <li> <p>What pattern is happening now (buffering / backlog)?: A backlog forms where items accumulate in the queue faster than they are consumed.</p> </li> </ol>"},{"location":"Embeded_Systems_2/Assignments/#lab-3-mutex","title":"Lab 3 Mutex","text":""},{"location":"Embeded_Systems_2/Assignments/#goal_2","title":"Goal","text":"<p>See a race condition happen with a shared counter, then fix it with a mutex.</p>"},{"location":"Embeded_Systems_2/Assignments/#code-lab-3-part-a","title":"Code Lab 3 Part A","text":"<p><pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> Why can the counter be wrong?</p>"},{"location":"Embeded_Systems_2/Assignments/#answer","title":"Answer","text":"<p>Because both tasks access and modify the shared variable at the same time without synchronization, causing race conditions.</p>"},{"location":"Embeded_Systems_2/Assignments/#code-lab-3-part-b","title":"Code Lab 3 Part B","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"Embeded_Systems_2/Assignments/#excersises_2","title":"Excersises","text":"<ol> <li>Remove the mutex again. Do you ever see weird behavior?</li> <li>Change priorities: TaskA priority 6, TaskB priority 4.</li> <li>What do you expect and why?</li> <li>In one sentence: what does a mutex \u201cguarantee\u201d?</li> </ol>"},{"location":"Embeded_Systems_2/Assignments/#answers_2","title":"Answers","text":"<ol> <li> <p>Remove the mutex again. Do you ever see weird behavior?: Yes, the counter sometimes skips or repeats values due to race conditions.</p> </li> <li> <p>Change priorities (TaskA = 6, TaskB = 4): TaskA runs more often because it has higher priority.</p> </li> <li> <p>What do you expect and why?: TaskA increments the counter more frequently since the scheduler favors higher-priority tasks.</p> </li> <li> <p>In one sentence: what does a mutex \u201cguarantee\u201d?: A mutex guarantees exclusive access to a shared variable so only one task can use it at a time.</p> </li> </ol>"},{"location":"Embeded_Systems_2/Excercises/","title":"Excercises","text":""},{"location":"Embeded_Systems_2/Excercises/#task-excercise","title":"Task Excercise","text":""},{"location":"Embeded_Systems_2/Excercises/#goal","title":"Goal","text":"<p>Use the task\u00b4s learned commands to create a program that uses 7 different tasks</p>"},{"location":"Embeded_Systems_2/Excercises/#what-to-watch-for","title":"What to watch for","text":"<p>-Task 1: Heartbeat</p> <p>-Task 2: Alive task</p> <p>-Task 3: Queue Struct Send</p> <p>-Task 4: Queue Struct Receive</p> <p>-Task 5 and 6: Mutex reading a button</p> <p>-Task 7: Error loggin for task 1-6</p>"},{"location":"Embeded_Systems_2/Excercises/#code-lab-1","title":"Code Lab 1","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_20\n#define BUTTON   GPIO_NUM_21 \n\nstatic const char *TAG = \"LAB1\";\n\nstatic SemaphoreHandle_t btn_mutex = NULL;\nstatic uint32_t task_counters[6] = {0};\n\ntypedef struct {\n    char id[20];\n    int value;\n} DataMessage;\n\nQueueHandle_t structQueue;\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        task_counters[0]++;\n\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nstatic void Live(void *pvParameters)\n{\n    while (1) {\n        task_counters[1]++;\n        ESP_LOGI(TAG, \"The pacient is alive (BPM=95)\");\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void sender_task(void *pvParameters)\n{\n    DataMessage myData;\n    strcpy(myData.id, \"CHARLY\");\n    int count = 0;\n\n    while (1) {\n        task_counters[2]++;\n        myData.value = count;\n\n        if (xQueueSend(structQueue, &amp;myData, pdMS_TO_TICKS(100)) == pdPASS) {\n\n        }\n\n        count++;\n        vTaskDelay(pdMS_TO_TICKS(1000)); \n    }\n}\n\nstatic void receiver_task(void *pvParameters)\n{\n    DataMessage receivedData;\n\n    while (1) {\n        task_counters[3]++;\n\n        if (xQueueReceive(structQueue, &amp;receivedData, portMAX_DELAY) == pdTRUE) {\n            ESP_LOGI(TAG, \"QUEUE RECIEVED, PATIENT: %s, VALUE: %d\", receivedData.id, receivedData.value);\n        }\n    }\n}\n\nstatic void mutex_button_task(void *pvParameters) {\n    int task_idx = (int)pvParameters; \n    const char* message = (task_idx == 4) ? \"I hate charly\" : \"I hate Javi\";\n\n    while (1) {\n        task_counters[task_idx]++;\n\n        if (xSemaphoreTake(btn_mutex, portMAX_DELAY) == pdTRUE) {\n\n            if (gpio_get_level(BUTTON) == 0) {\n                 ESP_LOGI(TAG, \"%s\", message);\n                 vTaskDelay(pdMS_TO_TICKS(200)); \n            }\n\n            xSemaphoreGive(btn_mutex); \n        }\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n\nstatic void monitor_task(void *pvParameters) {\n    uint32_t last_counters[6] = {0};\n\n    while (1) {\n        vTaskDelay(pdMS_TO_TICKS(5000));\n\n        for (int i = 0; i &lt; 6; i++) {\n            if (task_counters[i] == last_counters[i]) {\n                ESP_LOGE(\"MONITOR\", \"ERROR: Tarea %d detenida\", i);\n            } else {\n                last_counters[i] = task_counters[i];\n            }\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1\");\n\n    gpio_reset_pin(BUTTON);\n    gpio_set_direction(BUTTON, GPIO_MODE_INPUT);\n    gpio_pullup_en(BUTTON);\n\n    structQueue = xQueueCreate(10, sizeof(DataMessage));\n    btn_mutex = xSemaphoreCreateMutex();\n\n    if (structQueue == NULL || btn_mutex == NULL) {\n        ESP_LOGE(TAG, \"Error creating Queue or Mutex\");\n        return;\n    }\n\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(Live, \"Live\", 2048, NULL, 5, NULL);\n    xTaskCreate(sender_task, \"sender\", 2048, NULL, 5, NULL);\n    xTaskCreate(receiver_task, \"receiver\", 2048, NULL, 5, NULL);\n    xTaskCreate(mutex_button_task, \"BtnCharly\", 2048, (void*)4, 5, NULL);\n    xTaskCreate(mutex_button_task, \"BtnJavi\", 2048, (void*)5, 5, NULL);\n    xTaskCreate(monitor_task, \"Monitor\", 2048, NULL, 6, NULL);\n}\n</code></pre>"},{"location":"Embeded_Systems_2/Excercises/#evidence","title":"Evidence","text":""},{"location":"Proyectos_4/Proyecto_final/","title":"Proyecto final","text":"<p>Entrega final, donde se present\u00f3 el proyecto de \"Citizen Quack\" como un producto terminado y en su proceso </p>"},{"location":"Proyectos_4/Proyecto_final/#proyecto-terminado","title":"Proyecto terminado","text":"<p>Imagen del proyecto final terminado  </p>"},{"location":"Proyectos_4/Proyecto_final/#app-movil","title":"App M\u00f3vil","text":"<p>Imagen mostrando el funcionamiento de la app de medici\u00f3n, ense\u00f1ando su dise\u00f1o, datos y variables</p> <p></p>"},{"location":"Proyectos_4/Proyecto_final/#documento-de-entrega-final","title":"Documento de entrega final","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Proyecto_final/#presentacion-final","title":"Presentaci\u00f3n final","text":"<p>Presentaci\u00f3n final usada para el pitch de ventas de la clase final en el cual mostramos y hablamos sobre nuestro producto \"Citizen Quack\", tocando puntos clave como su mercado, costos generales, plan de negocios e inversi\u00f3n inicial del proyecto.</p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_1/","title":"Semana 1","text":""},{"location":"Proyectos_4/Semana_1/#syllabus","title":"Syllabus","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_1/#boceto-de-proyecto","title":"Boceto de proyecto","text":""},{"location":"Proyectos_4/Semana_3/","title":"Semana 3","text":""},{"location":"Proyectos_4/Semana_3/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_4/","title":"Semana 4","text":""},{"location":"Proyectos_4/Semana_4/#diagrama-de-gant","title":"Diagrama de Gant","text":"<p>https://g.repsona.com/p/gantt/2c7bc4f9-14d3-4a94-8e8b-f547bc3202e3</p>"},{"location":"Proyectos_4/Semana_5/","title":"Semana 5","text":""},{"location":"Proyectos_4/Semana_5/#marco-real-ganar-vale-la-pena","title":"Marco real ganar vale la pena","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_6/","title":"Semana 6","text":""},{"location":"Proyectos_4/Semana_6/#analisis-de-5-fuerzas","title":"An\u00e1lisis de 5 Fuerzas","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_6/#business-model-canvas","title":"Business Model Canvas","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_7/","title":"Semana 7","text":""},{"location":"Proyectos_4/Semana_7/#planeacion-de-costos-y-ciclos-del-proyecto","title":"Planeaci\u00f3n de costos y ciclos del proyecto","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_4/Semana_7/#excel-de-costos","title":"Excel de costos","text":"<p>\ud83d\udcca Ver o descargar Costos.xlsx</p>"},{"location":"Proyectos_4/Semana_8/","title":"Semana 8","text":""},{"location":"Proyectos_4/Semana_8/#patentes","title":"Patentes","text":"<p>Investigaci\u00f3n sobre otras patentes parecidas a nuestro proyecto </p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Sistemas_Embebidos/Tarea_1/","title":"Tareas","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-1-comparativa-de-microcontroladores","title":"Tarea 1: Comparativa de Microcontroladores","text":"<p>El objetivo de esta tarea es familiarizarnos con los diferentes tipos de microcontroladores y sus caracter\u00edsticas para as\u00ed poder elegir el ideal para nuestros futuros proyectos.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#proyecto-elegido","title":"Proyecto elegido","text":"<p>La comparaci\u00f3n ser\u00e1 en base a un proyecto el cual es un coche autonomo que tiene sensores para poder moverse libremente y as\u00ed saber si tiene un obst\u00e1culo que le impida su movimiento.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#tabla-comparativa","title":"Tabla comparativa","text":"Variables\\Microcontrolador ATmega328P (Arduino Uno) STM32F103C8T6 PIC18F4550 RP2040 (Raspberry Pi Pico) Perif\u00e9ricos 23 I/O, ADC(6), UART, SPI, I\u00b2C, PWM(6) 37 GPIO, ADC, DAC, UART, SPI, I\u00b2C, CAN, USB 35 I/O, ADC(10), UART, SPI, I\u00b2C, USB 2.0, PWM 26 GPIO, ADC(4), UART, SPI, I\u00b2C, PWM, PIO Memoria (Flash/RAM/EEPROM) 32 KB / 2 KB / 1 KB 64 KB / 20 KB / \u2014 32 KB / 2 KB / 256 B 2 MB ext. / 264 KB / \u2014 Ecosistema Arduino IDE STM32CubeIDE, Arduino, PlatformIO MPLAB X, XC8 Compiler SDK C/C++, MicroPython, Arduino Core Costo aprox $150 \u2013 $220 $90 \u2013 $180 $240 \u2013 $290 $100 \u2013 $200 Arquitectura AVR 8 bits ARM Cortex-M3 32 bits PIC 8 bits ARM Cortex-M0+ Dual-core 32 bits Velocidad de trabajo 16 MHz 72 MHz 48 MHz 133 MHz"},{"location":"Sistemas_Embebidos/Tarea_1/#conclusiones","title":"Conclusiones","text":"<ol> <li> <p>STM32F103: Muy buen balance de rendimiento en tiempo real, muchos timers/PWM, captura de entradas para encoders, ADC 12-bit r\u00e1pido, CAN/USB en variantes. Excelente para control PID a alta tasa y fusi\u00f3n b\u00e1sica de sensores.</p> </li> <li> <p>RP2040: Mucha RAM (264 KB), dos n\u00facleos, y PIO para decodificar encoders o protocolos con poca CPU. Ecosistema enorme (SDK C/C++, MicroPython, Arduino).</p> </li> <li> <p>ATmega328P Ecosistema y librer\u00edas accesibles, PWM/ADC suficientes para un proyecto b\u00e1sico, gran comunidad y m\u00e1s familiarizaci\u00f3n con el, pero una CPU lenta, poca RAM/Flash; se queda corto si aumentan sensores/encoders y la tasa de refresco.</p> </li> <li> <p>PIC18F4550: Robusto e industrial; USB nativo. Menos poder efectivo (8-bit), ecosistema/herramientas menos \u00e1giles para rob\u00f3tica, timers/ADC suficientes pero te quedar\u00e1s antes que con STM32/RP2040.</p> </li> </ol>"},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-2-outputs-basicos","title":"Tarea 2: Outputs B\u00e1sicos","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#contador-binario-4-bits","title":"Contador binario 4 bits","text":"<p>En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define LEDS_MASK ((1&lt;&lt;0) | (1&lt;&lt;1) | (1&lt;&lt;3) | (1&lt;&lt;4))   \nint main() {\n    stdio_init_all();\n\n    gpio_init(0); gpio_set_dir(0, GPIO_OUT);\n    gpio_init(1); gpio_set_dir(1, GPIO_OUT);\n    gpio_init(3); gpio_set_dir(3, GPIO_OUT);\n    gpio_init(4); gpio_set_dir(4, GPIO_OUT);\n\n    int estado = 0;\n\n    while (1) {\n        for (estado = 0; estado &lt; 16; estado++) {\n            gpio_put(0, estado &amp; (1&lt;&lt;0));\n            gpio_put(1, estado &amp; (1&lt;&lt;1));\n            gpio_put(3, estado &amp; (1&lt;&lt;2));  \n            gpio_put(4, estado &amp; (1&lt;&lt;3));\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#barrido-de-leds","title":"Barrido de leds","text":"<p>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0  \n#define LED1 1  \n#define LED2 3  \n#define LED3 4  \n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3}; // lo hice as\u00ed para no repetir 4 lineas de c\u00f3digo\n\nint main() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int posicion = 0;\n    int dir = 1;  \n\n    while (true) {\n        gpio_clr_mask(LED_MASK); \n\n        uint32_t bit = (1u &lt;&lt; LEDS[posicion]);\n        gpio_set_mask(bit);      \n\n        sleep_ms(300);\n\n        posicion += dir;\n\n        if (posicion == 4 || posicion == -1) {\n            gpio_clr_mask(LED_MASK);\n            dir = -dir;  \n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-sistema","title":"Diagrama del sistema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_1","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#secuencia-en-codigo-gray","title":"Secuencia en codigo Gray","text":"<p>Transformar c\u00f3digo binario en una secuencia en c\u00f3digo Gray</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\nint main() {\n\n    const uint LEDS[] = {0, 1, 3, 4};\n    const int Cantidad = 4;\n\n\n    for (int i = 0; i &lt; Cantidad; i++) {//Para evitar c\u00f3digo si son muchos pines\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], GPIO_OUT);\n    }\n\n    while (true) {\n\n        for (int n = 0; n &lt; 16; n++) {\n            int gray = n ^ (n &gt;&gt; 1); // F\u00f3rmula para convertir a Gray\n\n\n            for (int i = 0; i &lt; Cantidad; i++) {\n                int bit = (gray &gt;&gt; i) &amp; 1;\n                gpio_put(LEDS[i], bit);\n            }\n\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito_1","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_2","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-3-inputs","title":"Tarea 3: Inputs","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#compuertas-basicas-and-or-xor-con-2-botones","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>Qu\u00e9 debe hacer: Con dos botones A y B enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_3","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED   0\n#define LED2    1\n#define LED3   3\n\n#define Boton1   5\n#define Boton2   6\n\nint main() {\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(LED2);\n    gpio_set_dir(LED2, true);\n\n    gpio_init(LED3);\n    gpio_set_dir(LED3, true);\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);\n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);\n    gpio_pull_up(Boton2);\n\n    while (true) {\n        // Se invierte para que sea Pull-up\n        uint32_t b1 = !gpio_get(Boton1);\n        uint32_t b2 = !gpio_get(Boton2);\n\n        uint32_t AND = b1 &amp; b2;   \n        uint32_t OR  = b1 | b2; \n        uint32_t XOR = b1 ^ b2;\n\n        gpio_clr_mask((1u &lt;&lt; LED) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3));\n        gpio_set_mask((AND &lt;&lt; LED) |\n                      (OR  &lt;&lt; LED2)  |\n                      (XOR &lt;&lt; LED3));\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito_2","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_3","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#selector-ciclico-de-4-leds-con-avanceretroceso","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>Qu\u00e9 debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso y si dejas presionado no repite. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_4","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0  \n#define LED1 1  \n#define LED2 3  \n#define LED3 4  \n\n#define Boton1 5\n#define Boton2 6\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);  \n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);  \n    gpio_pull_up(Boton2);\n\n    int posicion = 0;\n    uint32_t Estadob1 = true;\n    uint32_t Estadob2 = true;\n\n    while (true) {\n        // Poner posici\u00f3n actual\n        gpio_clr_mask(LED_MASK);\n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]);\n\n\n        uint32_t Avance = gpio_get(Boton1);\n        uint32_t Retroceso = gpio_get(Boton2);\n\n        if (!Avance &amp;&amp; Estadob1) {\n            posicion++;\n            if (posicion &gt; 3) posicion = 0;\n        }\n\n        if (!Retroceso &amp;&amp; Estadob2) {\n            posicion--;\n            if (posicion &lt; 0) posicion = 3;\n        }\n\n        Estadob1 = Avance;\n        Estadob2 = Retroceso;\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama-del-circuito_3","title":"Diagrama del circuito","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_4","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-4-ping-pong","title":"Tarea 4: Ping-Pong","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#reglas-del-juego","title":"Reglas del juego","text":"<ol> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> </li> <li> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ol>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_5","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Led 0\n#define Led2 1\n#define Led3 2   // LED central\n#define Led4 3\n#define Led5 4\n#define Led6p 6  \n#define Led7p 8   \n\n#define BotonIzq 14     \n#define BotonDer 15     \n\n#define LED_MASK ((1u &lt;&lt; Led) | (1u &lt;&lt; Led2) | (1u &lt;&lt; Led3) | (1u &lt;&lt; Led4) | (1u &lt;&lt; Led5))\n\nconst uint LEDS[5] = {Led, Led2, Led3, Led4, Led5};\nint posicion = 2;  \nint dir = 1;        \nbool fallo = false;\nint fallo_jugador = -1; \n\n// ISR para botones\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (posicion == 0 &amp;&amp; gpio == BotonIzq) {\n        dir = 1;\n    } else if (posicion == 4 &amp;&amp; gpio == BotonDer) {\n        dir = -1;\n    } else {\n        fallo = true;\n        if (gpio == BotonIzq) {\n            fallo_jugador = 0; \n        } else if (gpio == BotonDer) {\n            fallo_jugador = 1; \n        }\n    }\n}\n\n\nvoid Inicioled() {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(Led3, 1);\n        sleep_ms(500);\n        gpio_put(Led3, 0); \n        sleep_ms(500);\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 5; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Led6p);\n    gpio_set_dir(Led6p, true);\n    gpio_init(Led7p);\n    gpio_set_dir(Led7p, true);\n\n    gpio_init(BotonIzq);\n    gpio_set_dir(BotonIzq, false);\n    gpio_pull_up(BotonIzq);\n    gpio_set_irq_enabled_with_callback(BotonIzq, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n    gpio_init(BotonDer);\n    gpio_set_dir(BotonDer, false);\n    gpio_pull_up(BotonDer);\n    gpio_set_irq_enabled_with_callback(BotonDer, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n\n    Inicioled();\n\n    while (true) {\n        gpio_clr_mask(LED_MASK); \n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]); \n\n        sleep_ms(300);\n\n        if (fallo) {\n            gpio_clr_mask(LED_MASK);\n\n            if (fallo_jugador == 0) {\n                gpio_put(Led6p, 1);\n                sleep_ms(5000);\n                gpio_put(Led6p, 0);\n            } else if (fallo_jugador == 1) {\n                gpio_put(Led7p, 1);\n                sleep_ms(5000);\n                gpio_put(Led7p, 0);\n            }\n\n            // reiniciar juego\n            fallo = false;\n            fallo_jugador = -1;\n            posicion = 2;\n            dir = 1;\n\n\n            Inicioled();\n            continue;\n        }\n\n        posicion += dir;\n\n        // Rebote fallido\n        if (posicion &lt; 0) {\n            fallo = true;\n            fallo_jugador = 0;\n        } else if (posicion &gt; 4) {\n            fallo = true;\n            fallo_jugador = 1;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquema","title":"Esquema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_5","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-5-ejercicios-de-medicion","title":"Tarea 5: Ejercicios de medici\u00f3n","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <p>Periodo promedio y tolerancia.</p> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS. Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#evidencia","title":"Evidencia","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_6","title":"C\u00f3digo","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN PICO_DEFAULT_LED_PIN\nstatic const int BLINK_MS = 1000;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#analisis","title":"An\u00e1lisis","text":"<p>Al generar una se\u00f1al por medio de temporizadores, al momento de medirla en el osciloscopio se pudo observar el peque\u00f1o delay que se genera al usar este modo.</p> <p>Se configur\u00f3 el osciloscopio con un voltaje de 1V, para as\u00ed poder observar correctamente las se\u00f1ales. El tiempo de parpadeo era de 1 segundo y en el osciloscopio se obtuvo un ciclo de 1.001 s. Es decir que tiene un delay de 1 milisegundo</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <p>Usa rearme acumulativo.</p> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo:</p> <p>Periodo promedio y desviaci\u00f3n respecto al nominal.</p> <p>Jitter pico-a-pico y/o RMS. Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#evidencia_1","title":"Evidencia","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_7","title":"C\u00f3digo","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       PICO_DEFAULT_LED_PIN\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 1000000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_1","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#comparacion","title":"Comparaci\u00f3n","text":"<p>Al comparar los dos modos, se encontr\u00f3 una diferencia entre el modo \u00b5s vs ciclos. El modo ciclos es m\u00e1s preciso y no genera ning\u00fan delay perceptible en el osciloscopio a diferncia del modo \u00b5s que tiene una diferencia de 1 ms.</p> <p>Con esta informaci\u00f3n se puede concluir que para tener un timer preciso el uso de los ciclos es el ideal y el mejor para implementar en futuros proyectos, ya que genera un timer \u00f3ptimo y sin delays. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-6-ejercicios-de-programacion","title":"Tarea 6: Ejercicios de programaci\u00f3n","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#ejercicio-1-cuatro-alarmas-cuatro-leds-a-distintas-frecuencias","title":"Ejercicio 1: Cuatro alarmas / cuatro LEDs a distintas frecuencias","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_8","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     0\n#define LED1_PIN     1\n#define LED2_PIN     3\n#define LED3_PIN     4\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 200000u;\nstatic const uint32_t INTERVALO1_US = 400000u;\nstatic const uint32_t INTERVALO2_US = 600000u;\nstatic const uint32_t INTERVALO3_US = 800000u;\n\n// ISR \u00daNICA para el TIMER\nstatic void on_timer_irq(void) {\n    uint32_t status = timer_hw-&gt;intr;  \n    timer_hw-&gt;intr = status;\n\n    if (status &amp; (1u &lt;&lt; ALARM0_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n        next0_us += INTERVALO0_US;\n        timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM1_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n        next1_us += INTERVALO1_US;\n        timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM2_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n        next2_us += INTERVALO2_US;\n        timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM3_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n        next3_us += INTERVALO3_US;\n        timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n    }\n}\n\nint main() {\n    gpio_init(LED0_PIN); gpio_set_dir(LED0_PIN, GPIO_OUT); gpio_put(LED0_PIN, 0);\n    gpio_init(LED1_PIN); gpio_set_dir(LED1_PIN, GPIO_OUT); gpio_put(LED1_PIN, 0);\n    gpio_init(LED2_PIN); gpio_set_dir(LED2_PIN, GPIO_OUT); gpio_put(LED2_PIN, 0);\n    gpio_init(LED3_PIN); gpio_set_dir(LED3_PIN, GPIO_OUT); gpio_put(LED3_PIN, 0);\n\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    hw_clear_bits(&amp;timer_hw-&gt;intr,\n                  (1u &lt;&lt; ALARM0_NUM) |\n                  (1u &lt;&lt; ALARM1_NUM) |\n                  (1u &lt;&lt; ALARM2_NUM) |\n                  (1u &lt;&lt; ALARM3_NUM));\n\n    int irq_num = timer_hardware_alarm_get_irq_num(timer_hw, 0);\n    irq_set_exclusive_handler(irq_num, on_timer_irq);\n\n    hw_set_bits(&amp;timer_hw-&gt;inte,\n                (1u &lt;&lt; ALARM0_NUM) |\n                (1u &lt;&lt; ALARM1_NUM) |\n                (1u &lt;&lt; ALARM2_NUM) |\n                (1u &lt;&lt; ALARM3_NUM));\n\n    irq_set_enabled(irq_num, true);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquema_1","title":"Esquema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_6","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#ejercicio-2","title":"Ejercicio 2","text":"<p>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_9","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Leds 5\n#define Delayminimo 100\n#define Delaymaximo 1000\n#define Delay 100\n\nconst uint Boton1 = 14;     \nconst uint Boton2 = 15;  \nconst uint Botonmasvel = 13;  \nconst uint Botonmenosvel = 12;\nconst uint LEDS[Leds] = {0, 1, 2, 3, 4};\nconst uint LedP1 = 6;    // LED indicador derecha\nconst uint LedP2 = 8;    // LED indicador izquierda\n\nvolatile bool Reb1 = false;\nvolatile bool Reb2 = false;\nvolatile bool Subiovel = false;\nvolatile bool Bajovel = false;\n\nvoid button_isr(uint gpio, uint32_t events) {\n    if (gpio == Boton1) Reb1 = true;\n    else if (gpio == Boton2) Reb2 = true;\n    else if (gpio == Botonmasvel) Subiovel = true;\n    else if (gpio == Botonmenosvel) Bajovel = true;\n}\n\nvoid score_point(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main() {\n    // Anotaci\u00f3n de puntos\n    gpio_init(LedP1); gpio_set_dir(LedP1, true);\n    gpio_init(LedP2); gpio_set_dir(LedP2, true);\n\n\n    gpio_init(Boton1); gpio_set_dir(Boton1, false); gpio_pull_up(Boton1);\n    gpio_set_irq_enabled_with_callback(Boton1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(Boton2); gpio_set_dir(Boton2, false); gpio_pull_up(Boton2);\n    gpio_set_irq_enabled(Boton2, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmasvel); gpio_set_dir(Botonmasvel, false); gpio_pull_up(Botonmasvel);\n    gpio_set_irq_enabled(Botonmasvel, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmenosvel); gpio_set_dir(Botonmenosvel, false); gpio_pull_up(Botonmenosvel);\n    gpio_set_irq_enabled(Botonmenosvel, GPIO_IRQ_EDGE_FALL, true);\n\n    // LEDs del juego\n    for (int i = 0; i &lt; Leds; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int current_led = Leds / 2;\n    int direction = 0;\n    bool game_started = false;\n    int delay_ms = 400; // velocidad inicial\n\n    gpio_put(LEDS[current_led], 1);\n\n    while (true) {\n        // Ajustar velocidad\n        if (Subiovel) {\n            if (delay_ms &gt; Delayminimo) delay_ms -= Delay;\n            Subiovel = false;\n        }\n        if (Bajovel) {\n            if (delay_ms &lt; Delaymaximo) delay_ms += Delay;\n            Bajovel = false;\n        }\n\n\n        if (!game_started) {\n            if (Reb1) { direction = 1; game_started = true; Reb1 = false; gpio_put(LEDS[current_led], 0);}\n            else if (Reb2) { direction = -1; game_started = true; Reb2 = false; gpio_put(LEDS[current_led], 0);}\n            else continue;\n        }\n\n        gpio_put(LEDS[current_led], 1);\n        sleep_ms(delay_ms);  //el delay depende del bot\u00f3n\n        gpio_put(LEDS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == -1) {\n            if (Reb1) { direction = 1; current_led = 0; Reb1 = false; }\n            else { score_point(LedP1); current_led = Leds/2; direction = 1; }\n        }\n        if (current_led == Leds) {\n            if (Reb2) { direction = -1; current_led = Leds - 1; Reb2 = false; }\n            else { score_point(LedP2); current_led = Leds/2; direction = -1; }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquema_2","title":"Esquema","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_7","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#examen-1-simon-dice","title":"EXAMEN 1: Sim\u00f3n dice","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> <p>La persona jugadora debe repetir la secuencia con 4 botones.</p> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> <p>Reglas del juego (obligatorias) Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_10","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n#define Rondas 15\n#define Parpadeo 400\n#define Pausa 250\n#define Debounce 50\n\n#define LED0 0\n#define LED1 1\n#define LED2 3\n#define LED3 4\n\n#define BTN0 27\n#define BTN1 28\n#define BTN2 14\n#define BTN3 15\n\n#define SegmentoA  16\n#define SegmentoB  17\n#define SegmentoC  18\n#define SegmentoD 26\n#define SegmentoDp  20\n#define SegmentoE  21\n#define SegmentoF  22\n#define SegmentoG  2\n\n// arrays de pines para recorrer\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\nconst uint Botones[4] = {BTN0, BTN1, BTN2, BTN3};\nconst uint Segmentos[8] = {SegmentoA, SegmentoB, SegmentoC, SegmentoDp, SegmentoE, SegmentoF, SegmentoG, SegmentoD};\n\n//\u00c1nodo com\u00fan, 0=1, 1=0\nconst bool MapaDisplay[16][8] = {\n    {0,0,0,0,0,0,1,1}, // 0\n    {1,0,0,1,1,1,1,1}, // 1\n    {0,0,1,0,0,1,0,1}, // 2\n    {0,0,0,0,1,1,0,1}, // 3\n    {1,0,0,1,1,0,0,1}, // 4\n    {0,1,0,0,1,0,0,1}, // 5\n    {0,1,0,0,0,0,0,1}, // 6\n    {0,0,0,1,1,1,1,1}, // 7\n    {0,0,0,0,0,0,0,1}, // 8\n    {0,0,0,0,1,0,0,1}, // 9\n    {0,0,0,1,0,0,0,1}, // A\n    {1,1,0,0,0,0,0,1}, // b\n    {0,1,1,0,0,0,1,1}, // C\n    {1,0,0,0,0,1,0,1}, // d\n    {0,1,1,0,0,0,0,1}, // E\n    {0,1,1,1,0,0,0,1}  // F\n};\n\nuint8_t Sequencia[Rondas];\nint Num_sequencia = 0;\n\nvoid MuestraDisplay(uint8_t n) {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_put(Segmentos[i], MapaDisplay[n &amp; 0xF][i]);\n    }\n}\n\nvoid Blink(uint8_t iL, uint32_t ms) {\n    gpio_put(LEDS[iL], 1);\n    sleep_ms(ms);\n    gpio_put(LEDS[iL], 0);\n}\n\nint PresionaBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) { \n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); \n                return i;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid EsperarBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) {\n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); // espera a quitar el bot\u00f3n presionado\n                return;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid IniciarLeds() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n}\n\nvoid IniciarBotones() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(Botones[i]);\n        gpio_set_dir(Botones[i], false);\n        gpio_pull_up(Botones[i]);\n    }\n}\n\nvoid IniciarDisplay() {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_init(Segmentos[i]);\n        gpio_set_dir(Segmentos[i], true);\n    }\n}\n\n// Reproduce la secuencia actual\nvoid ReproducirSecuencia(int lim) {\n    sleep_ms(300);\n    for (int i = 0; i &lt; lim; i++) {\n        Blink(Sequencia[i], Parpadeo);\n        sleep_ms(Pausa);\n    }\n}\n\n// Game Over\nvoid GameOver(uint8_t score) {\n    MuestraDisplay(score &gt; 15 ? 15 : score);\n\n\n    for (int j = 0; j &lt; 6; j++) {\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 1);\n        sleep_ms(120);\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 0);\n        sleep_ms(120);\n    }\n\n\n    EsperarBoton();\n\n    Num_sequencia = 0;\n    MuestraDisplay(0);\n}\n\n// Genera un nuevo color aleatorio y lo agrega a la secuencia\nvoid SiguienteRonda() {\n    Sequencia[Num_sequencia++] = rand() &amp; 0x3;\n    if (Num_sequencia &gt; Rondas) Num_sequencia = Rondas;\n}\n\nbool PresionarSecuencia() { //La funci\u00f3n que tiene que hacer el jugador f\u00edsicamente\n    for (int i = 0; i &lt; Num_sequencia; i++) {\n        int presionar = PresionaBoton();\n        Blink(presionar, 120);\n        if (presionar != Sequencia[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main() {\n    stdio_init_all();\n    IniciarLeds();\n    IniciarBotones();\n    IniciarDisplay();\n\n    // Aleatoriedad: ADC + tiempo\n    adc_init();\n    adc_gpio_init(26);\n    adc_select_input(0);\n    uint16_t noise = adc_read();\n    srand(to_us_since_boot(get_absolute_time()) ^ noise);\n\n    MuestraDisplay(0);\n\n    while (1) {\n\n        EsperarBoton();\n\n        while (1) {\n            SiguienteRonda();\n            MuestraDisplay(Num_sequencia);\n            sleep_ms(400);\n            ReproducirSecuencia(Num_sequencia);\n\n            bool Correcto = PresionarSecuencia();\n\n            if (!Correcto) {\n                GameOver(Num_sequencia - 1);\n                break; // reinicia juego\n            }\n\n            if (Num_sequencia &gt;= Rondas) {\n                GameOver(Rondas);\n                break; // reinicia juego\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_2","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_8","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-7","title":"Tarea 7","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#71-control-de-duty-cycle-motor-dc","title":"7.1: Control de Duty Cycle \u2014 Motor DC","text":"<p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_11","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// Pines puente H TB6612\n#define PWMA   0   \n#define AIN1   1   \n#define AIN2   2   \n#define STBY   3   \n\n#define BTN_LOW   16\n#define BTN_MED   17\n#define BTN_HIGH  18\n\n#define F_PWM_HZ 2000   \n#define TOP 1023       \n\n#define DUTY_LOW   (TOP * 30 / 100)   // 30%\n#define DUTY_MED   (TOP * 60 / 100)   // 60%\n#define DUTY_HIGH  (TOP * 90 / 100)   // 90%\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(AIN1);\n    gpio_set_dir(AIN1, GPIO_OUT);\n    gpio_put(AIN1, 1);\n\n    gpio_init(AIN2);\n    gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_put(AIN2, 0);\n\n    gpio_init(STBY);\n    gpio_set_dir(STBY, GPIO_OUT);\n    gpio_put(STBY, 1);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    uint chan  = pwm_gpio_to_channel(PWMA);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    gpio_init(BTN_LOW);\n    gpio_set_dir(BTN_LOW, GPIO_IN);\n    gpio_pull_up(BTN_LOW);\n\n    gpio_init(BTN_HIGH);\n    gpio_set_dir(BTN_HIGH, GPIO_IN);\n    gpio_pull_up(BTN_HIGH);\n\n    while (1) {\n        if (!gpio_get(BTN_LOW)) {\n            pwm_set_chan_level(slice, chan, DUTY_LOW);\n        }\n\n        else if (!gpio_get(BTN_HIGH)) {\n            pwm_set_chan_level(slice, chan, DUTY_HIGH);\n        }\n        sleep_ms(100); \n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_3","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_9","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#72-control-de-frecuencia-cancion-con-buzzer","title":"7.2: Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":"<p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_12","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdint.h&gt;\n\n\n#define Buzzer 2\n#define TEMPO 200   // BPM\n\n#define DO3   34\n#define RE3   61\n#define MI3   68\n#define FA3   78\n#define SOL3  82\n#define SOLs3 111\n#define LA3   123\n#define SI3   151\n\n#define DO4   220\n#define DOs4  184\n#define RE4   250\n#define REs4  218\n#define MI4   282  \n#define FA4   300\n#define FAs4  277\n#define SOLb4 277\n#define SOL4  330\n#define SOLs4 350\n#define LAb4  350\n#define LA4   370\n#define LAs4  392\n#define SIb4  392\n#define SI4   420\n\n#define DO5   442\n#define DOs5  457\n#define RE5   495\n#define REs5  523\n#define MIb5  523\n#define MI5   560\n#define FA5   603\n#define FAs5  630\n#define SOL5  660\n#define SOLs5 735\n#define LA5   755\n#define LAs5  835\n#define SI5   845\n\n#define DO6   880\n\n#define SILENCIO 0\n\n\n// FIGURAS\n#define REDONDA   4.0f\n#define BLANCAP   3.0f\n#define BLANCA    2.0f\n#define NEGRA     1.0f\n#define CORCHEA   0.5f\n#define DCORCHEA  0.25f\n\nconst float reloj = 125000000.0f; // reloj 125 MHz\nuint slice_num;\nuint chan_num;\n\n// ---------- UTIL ----------\nstatic inline int duracion_ms(float figura) {\n    float negra_ms = 60000.0f / (float)TEMPO;\n    return (int)(figura * negra_ms + 0.5f);\n}\n\nvoid iniciar_pwm(uint gpio) {\n    gpio_set_function(gpio, GPIO_FUNC_PWM);\n    slice_num = pwm_gpio_to_slice_num(gpio);\n    chan_num  = pwm_gpio_to_channel(gpio);\n    pwm_set_enabled(slice_num, true);\n}\n\nvoid reproducir_nota(int frecuencia, float figura) {\n    if (frecuencia == SILENCIO) {\n        pwm_set_chan_level(slice_num, chan_num, 0);\n        sleep_ms(duracion_ms(figura));\n        return;\n    }\n\n    uint32_t wrap = 0;\n    float clkdiv = 1.0f;\n    for (int d = 1; d &lt;= 256; d++) {\n        float wrapf = reloj / ((float)d * (float)frecuencia) - 1.0f;\n        if (wrapf &gt;= 1.0f &amp;&amp; wrapf &lt;= 65535.0f) {\n            clkdiv = (float)d;\n            wrap = (uint32_t)(wrapf + 0.5f);\n            break;\n        }\n    }\n\n    if (wrap == 0) {\n        wrap = 65535;\n        clkdiv = reloj / ((wrap + 1) * (float)frecuencia);\n        if (clkdiv &lt; 1.0f) clkdiv = 1.0f;\n        if (clkdiv &gt; 256.0f) clkdiv = 256.0f;\n    }\n\n    pwm_set_clkdiv(slice_num, clkdiv);\n    pwm_set_wrap(slice_num, wrap);\n    pwm_set_chan_level(slice_num, chan_num, wrap / 2);\n\n    sleep_ms(duracion_ms(figura));\n\n    pwm_set_chan_level(slice_num, chan_num, 0);\n    sleep_ms(30);\n}\n\n\ntypedef struct {\n    int nota;\n    float figura;\n} Nota_t;\n\n\nNota_t escala[] = {\n    {MIb5, NEGRA},{SILENCIO, BLANCA}, {RE4, NEGRA}, {SILENCIO, BLANCA}, {MI4, NEGRA}, {SILENCIO, BLANCA}, {FA4, NEGRA}, {SILENCIO, BLANCA}, {SOL4, NEGRA}, {SILENCIO, BLANCA}, {LA4, NEGRA}, {SILENCIO, BLANCA}, {SI4, NEGRA}, {SILENCIO,BLANCA},\n {DO5, NEGRA}, {SILENCIO, BLANCA}, {RE5, NEGRA}, {SILENCIO, BLANCA}, {MI5, NEGRA}, {SILENCIO, BLANCA}, {FA5, NEGRA}, {SILENCIO, BLANCA}, {SOL5, NEGRA}, {SILENCIO, BLANCA}, {LA5, NEGRA}, {SILENCIO, BLANCA}, {SI5, NEGRA}, {SILENCIO,BLANCA}, {DO6,NEGRA}\n};\n\n\nNota_t cumple[] = {\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {FA4, NEGRA}, {MI4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {DO5, CORCHEA}, {LA4, NEGRA}, {FA4, NEGRA}, {MI4, NEGRA}, {RE4, 2.0f},\n    {SI4, NEGRA}, {SI4, CORCHEA}, {LA4, CORCHEA}, {FA4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f}\n};\n\nNota_t mario[] = { {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, NEGRA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA},\n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {DO5, CORCHEA}, {DO5, CORCHEA},  {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {MI5, NEGRA}, {SILENCIO, REDONDA}, \n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, BLANCA},\n{DO5, BLANCA}, {SILENCIO, DCORCHEA}, {SOL4, BLANCA}, {SILENCIO, DCORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SILENCIO, DCORCHEA}, {SI4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {FA4, CORCHEA}, {SOL4, BLANCAP}, {SILENCIO, REDONDA}, {SILENCIO, REDONDA}\n};\n\n\n// ---------- Funci\u00f3n gen\u00e9rica ----------\nvoid reproducir_melodia(Nota_t *melodia, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        reproducir_nota(melodia[i].nota, melodia[i].figura);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    iniciar_pwm(Buzzer);\n\n    Nota_t *melodia = mario;  // seleccionar la funci\u00f3n de melod\u00eda, cambiar mario por la que sea\n    int n = sizeof(mario) / sizeof(mario[0]);\n\n\n    while (1) {\n        reproducir_melodia(melodia, n);\n        sleep_ms(500); // pausa para el bucle de la melod\u00eda\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_4","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#video_10","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#73-generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"7.3: Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_13","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWMA 0       \n#define FS   2000   \n#define F_SENO 60    \n#define TOP   1023   \n\n#define ALARM0_NUM 0\n#define ALARM0_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n\n#define TABLA_T (FS / F_SENO)\n\nuint16_t tabla_sen[TABLA_T];\nvolatile int x = 0;\n\nvoid alarm0_isr() {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    // Actualizar PWM con el siguiente valor del seno\n    pwm_set_gpio_level(PWMA, tabla_sen[x]);\n    x = (x + 1) % TABLA_T;\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n}\n\nint main() {\n    stdio_init_all();\n\n    // === Generar tabla de seno ===\n    for (int i = 0; i &lt; TABLA_T; i++) {\n        float ang = 2 * M_PI * i / TABLA_T;\n        float s = (sinf(ang) + 1.0f) / 2.0f;  // Normalizado 0\u20131\n        tabla_sen[i] = (uint16_t)(s * TOP);\n    }\n\n    // === Configurar PWM en PWMA ===\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    float f_clk = 125000000.0f; // clock base 125 MHz\n    float div = f_clk / (FS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    irq_set_exclusive_handler(ALARM0_IRQ, alarm0_isr);\n    irq_set_enabled(ALARM0_IRQ, true);\n\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n\n    while (1) {\n        tight_loop_contents(); \n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#diagrama_5","title":"Diagrama","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#evidencia_2","title":"Evidencia","text":"<p>Se\u00f1al de entrada del PWM a 2kHz  Se\u00f1al de salida del filtro a 60Hz </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#tarea-8-uart","title":"Tarea 8 UART","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#1-por-medio-de-comunicacion-entre-dos-pico-2-lograr-accionar-leds-con-botones","title":"1 - Por medio de comunicaci\u00f3n entre dos Pico 2 , lograr accionar leds con botones.","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-echo","title":"C\u00f3digo echo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-receptor","title":"C\u00f3digo receptor","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_11","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#2-por-medio-de-la-consola-lograr-prender-leds-conectados-a-las-pico-2","title":"2 - Por medio de la consola lograr prender leds conectados a las Pico 2.","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-con-1-caracter","title":"C\u00f3digo con 1 caracter","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define BTN 3\n#define LED 2\n\n\n\nint main() {\n\n\n    stdio_init_all();\n\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(BTN);\n    gpio_set_dir(BTN, false);\n    gpio_pull_up(BTN);\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n            if (c == '1') {\n                gpio_put(LED, 1);  \n                printf(\"LED encendido!\\n\");\n            } \n\n            else {\n                gpio_put(LED, 0);  \n\n            }\n         }\n\n        bool pressed = !gpio_get(BTN);  \n        if (pressed) {\n            printf(\"Bot\u00f3n presionado!\\n\");\n            uart_putc(UART_ID, '1');\n            sleep_ms(300); \n\n\n        }\n         sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-con-un-string","title":"C\u00f3digo con un string","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all(); // Inicializa USB serial\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico listo] Comunicaci\u00f3n UART iniciando...\\n\");\n\n    // Inicializa UART antes de asignar pines\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // Configuraci\u00f3n del LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string mensaje_usb = \"\";\n    string mensaje_uart = \"\";\n\n    while (true) {\n        //Escritura mensaje\n        int ch = getchar_timeout_us(0); // no bloqueante\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    uart_puts(UART_ID, (mensaje_usb + \"\\n\").c_str());\n                    printf(\"Mensaje enviado: %s\\n\", mensaje_usb.c_str());\n                    mensaje_usb = \"\";\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        //Lectura en UART\n        while (uart_is_readable(UART_ID)) {\n            char ch_uart = uart_getc(UART_ID);\n\n            if (ch_uart == '\\n' || ch_uart == '\\r') {\n                if (!mensaje_uart.empty()) {\n                    printf(\"Mensaje recibido: %s\\n\", mensaje_uart.c_str());\n\n                    // Comparar informaci\u00f3n\n                    if (mensaje_uart == \"on\" || mensaje_uart == \"ON\") {\n                        gpio_put(LED_PIN, 1);\n                        printf(\"LED encendido\\n\");\n                    } else if (mensaje_uart == \"off\" || mensaje_uart == \"OFF\") {\n                        gpio_put(LED_PIN, 0);\n                        printf(\"LED apagado\\n\");\n                    } else {\n                        printf(\"Comando desconocido.\\n\");\n                    }\n\n                    mensaje_uart = \"\";\n                }\n            } else {\n                mensaje_uart += ch_uart;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_12","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#3-elaborar-un-hanshake","title":"3 - Elaborar un Hanshake.","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-maestro","title":"C\u00f3digo maestro","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico A listo] Escribe 'conectar' para iniciar handshake.\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string usb_msg = \"\";\n    string uart_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer comandos desde USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        // Leer mensajes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"[Recibido]: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"ok\") {\n                            printf(\"Pico B respondi\u00f3 OK.\\n\");\n                        } else if (uart_msg == \"conectado\") {\n                            printf(\"Conexi\u00f3n establecida \\n\");\n                            conectado = true;\n                        } else {\n                            printf(\"[Error] Mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"[LED] Encendido (por comando remoto)\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"[LED] Apagado (por comando remoto)\\n\");\n                        } else {\n                            printf(\"Error: Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo-esclavo","title":"C\u00f3digo esclavo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\nPico B listo, Esperando handshake desde el otro dispositivo...\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string uart_msg = \"\";\n    string usb_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer mensajes entrantes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"Recibido: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"conectar\") {\n                            uart_puts(UART_ID, \"ok\\n\");\n                            sleep_ms(300);\n                            uart_puts(UART_ID, \"conectado\\n\");\n                            conectado = true;\n                            printf(\"Conexi\u00f3n establecida\\n\");\n                        } else {\n                            uart_puts(UART_ID, \"error\\n\");\n                            printf(\"Error, mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"LED encendido\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"LED apagado\\n\");\n                        } else {\n                            printf(\"[Error] Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_13","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#examen-2","title":"Examen 2","text":"<p>Control de Servomotores con comandos Hardware m\u00ednimo 1 \u00d7 servomotor en un pin PWM (50 Hz).</p> <p>3 \u00d7 botones:</p> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> <p>Pi pico 2</p> <p>Modos de operaci\u00f3n 1) Modo Entrenamiento Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> <p>Borrar (alias: clear, borrar)</p> <p>Sintaxis: Borrar</p> <p>Efecto: elimina la lista completa de posiciones.</p> <p>Respuesta: OK.</p> <p>Escribir (alias: write, escribir)</p> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> <p>vi son enteros en 0\u2013180.</p> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> <p>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</p> <p>2) Modo Continuo Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> <p>3) Modo Step BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> <p>En cada cambio de posici\u00f3n:</p> <p>mover el servo a la posici\u00f3n seleccionada;</p> <p>imprimir posX: V.</p> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> <p>INFO IMPORTANTE: El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 2\n#define BTN_ATRAS 14\n#define BTN_ADELANTE 13\n#define BTN_MODE 16\n#define UARTID uart0\n#define BAUDIOS 115200\n#define TX 0\n#define RX 1\n#define MOVIMIENTOS 10\n#define TOP 20000\n\nint posiciones[MOVIMIENTOS] = {0};\nint num_pos = 0;\nint modo = 1, idx = 0;\nvolatile bool cambio_modo = false;\n\n//FUNCIONES \ninline int angle_to_pulse(int a){\n    return 450+(a*1200)/180;\n}\n//solo llama esa parte del codigo para llamar lo de adentro \n//de angle to pulse del servo\ninline void set_servo(uint s,uint c,int a){\n    pwm_set_chan_level(s,c,angle_to_pulse(a));\n}\n\nvoid borrar_lista(){\n    for(int i=0;i&lt;MOVIMIENTOS;i++) \n    posiciones[i]=0;\n    num_pos=0;\n}\nbool lista_vacia(){\n    if(num_pos==0) \n        return true;\n    for(int i=0;i&lt;num_pos;i++) \n        if(posiciones[i]!=0)\n            return false;\n    return true;\n}\nvoid imprimir_lista(){\n    printf(\"Lista actual: \");\n    for(int i=0;i&lt;MOVIMIENTOS;i++){\n        printf(\"%d\",posiciones[i]); if(i&lt;MOVIMIENTOS-1)printf(\", \"); \n    }\n    printf(\"\\n\");\n}\n//pasa todo a minusculas\nvoid str_tolower(string &amp;s){for(auto &amp;c:s)c=tolower(c);}\n\n//ISR\nvoid cambio_isr(uint gpio,uint32_t events){cambio_modo=true;}\n\nint main(){\n    stdio_init_all();\n    sleep_ms(1500);\n\n    uart_init(UARTID,BAUDIOS);\n    gpio_set_function(TX,GPIO_FUNC_UART);\n    gpio_set_function(RX,GPIO_FUNC_UART);\n    uart_set_format(UARTID,8,1,UART_PARITY_NONE);\n\n    // SERVO\n    gpio_set_function(SERVO_PIN,GPIO_FUNC_PWM);\n    uint slice=pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan=pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_clkdiv(slice,150.0f); \n    pwm_set_wrap(slice,TOP);\n    pwm_set_enabled(slice,true);\n\n    gpio_init(BTN_ATRAS);\n    gpio_set_dir(BTN_ATRAS,false);\n    gpio_pull_up(BTN_ATRAS);\n    gpio_init(BTN_ADELANTE);\n    gpio_set_dir(BTN_ADELANTE,false);\n    gpio_pull_up(BTN_ADELANTE);\n    gpio_init(BTN_MODE);\n    gpio_set_dir(BTN_MODE,false); \n    gpio_pull_up(BTN_MODE);\n    gpio_set_irq_enabled_with_callback(BTN_MODE,GPIO_IRQ_EDGE_FALL,true,&amp;cambio_isr);\n\n    printf(\"\\n=== MODO 1: ENTRENAMIENTO ===\\nComandos: escribir / borrar\\n\");\n\n    string input;\n    bool tope_adelante=1,tope_atras=1;\n    while(true){\n        //CAMBIO DE MODO\n        if(cambio_modo){\n            cambio_modo=false;\n            modo=(modo%3)+1;\n            idx=0;\n            printf(\"\\n=== CAMBIO A MODO %d ===\\n\",modo);\n\n            if(!lista_vacia()){\n                set_servo(slice,chan,posiciones[0]);\n                sleep_ms(500);\n            }\n            if(modo==1) printf(\"Modo entrenamiento: escribir / borrar\\n\");\n            if(modo==2) printf(\"Modo repetici\u00f3n autom\u00e1tica.\\n\");\n            if(modo==3) printf(\"Modo paso a paso con botones.\\n\");\n        }\n        //MODO 1 \n        if(modo==1){\n            int ch=getchar_timeout_us(0);\n            //uart de clase para controlar la consola\n            if(ch!=PICO_ERROR_TIMEOUT){\n                if(ch=='\\r'||ch=='\\n'){\n                    if(!input.empty()){\n                        string cmd=input; \n                        str_tolower(cmd);\n                        if(cmd==\"borrar\"||cmd==\"clear\"){\n                            borrar_lista();printf(\"OK.\\n\");\n                            imprimir_lista();\n                        }\n                        else if(cmd.find(\"escribir\")==0||cmd.find(\"write\")==0){\n                            printf(\"\u00bfCu\u00e1ntos valores (1\u201310)?: \");\n                            fflush(stdout);\n                            string n_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; n_str+=(char)c;\n                                }\n                            }\n                            //string to int\n                            int n=stoi(n_str);\n                            if(n&lt;1||n&gt;MOVIMIENTOS){\n                                printf(\"Fuera de rango.\\n\");\n                                input.clear();\n                                continue;\n                            }\n                            printf(\"Ingrese %d valores (0\u2013180) separados por espacios:\\n\",n);\n                            //fuerza la salida del texto en el monitor serial\n                            fflush(stdout);\n                            string val_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; val_str+=(char)c;\n                                }\n                            }\n                            borrar_lista();\n                            int i=0; \n                            size_t pos=0;\n                            while(i&lt;n &amp;&amp; pos&lt;val_str.size()){\n                                //para que no tenga signo y siempre sea +\n                                size_t e=val_str.find(' ',pos);\n                                int v=stoi(val_str.substr(pos,e-pos));\n                                if(v&lt;0||v&gt;180){\n                                    printf(\"Valor fuera de rango.\\n\");break;\n                                }\n                                posiciones[i++]=v;\n                                if(e==string::npos)break; pos=e+1;\n                            }\n                            num_pos=i;\n                            printf(\"OK.\\n\");\n                            imprimir_lista();\n                        }\n                        else printf(\"Comando no reconocido.\\n\");\n                        input.clear();\n                    }\n                } else input+=(char)ch; //agregar el caracter al string input\n            }\n        }\n\n        //MODO 2\n        else if(modo==2){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");sleep_ms(1000);\n            }\n            else{\n                for(int i=0;i&lt;num_pos;i++){\n                    if(cambio_modo)break;\n                    set_servo(slice,chan,posiciones[i]);\n                    sleep_ms(1500);\n                }\n            }\n        }\n\n        //MODO 3\n        else if(modo==3){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");\n                sleep_ms(1000);\n            }\n            else{\n                set_servo(slice,chan,posiciones[idx]);\n                bool adelante=gpio_get(BTN_ADELANTE);\n                bool atras=gpio_get(BTN_ATRAS);\n                if(!adelante &amp;&amp; tope_adelante){ \n                    if(idx&lt;num_pos-1 &amp;&amp; posiciones[idx+1]!=0){\n                        idx++;\n                        set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Avance a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Fin de secuencia.\\n\");\n                }\n                if(!atras &amp;&amp; tope_atras){\n                    if(idx&gt;0){\n                        idx--;\n                        set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Retroceso a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Inicio de secuencia.\\n\");\n                }\n                tope_adelante=adelante; \n                tope_atras=atras;\n                sleep_ms(100);\n            }\n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#video_14","title":"Video","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#proyecto-final","title":"Proyecto final","text":""},{"location":"Sistemas_Embebidos/Tarea_1/#capstone-micromouse","title":"Capstone Micromouse","text":"<p>El proyecto Micromouse consiste en dise\u00f1ar y programar un robot m\u00f3vil aut\u00f3nomo capaz de explorar un laberinto, construir un mapa y ejecutar una carrera r\u00e1pida (fast run) desde el inicio hasta el objetivo en el centro.</p>"},{"location":"Sistemas_Embebidos/Tarea_1/#materiales-utilizados","title":"Materiales utilizados","text":"<ol> <li>Raspberry Pi Pi Pico2</li> <li>Sensores Ultras\u00f3nicos HC-SR04</li> <li>Puente H TB6612FNG</li> <li>Motores</li> <li>Aceler\u00f3metro MPU6050</li> <li>Reguladores de voltaje de 5v y 3.3v</li> <li>Carcasa impresa en 3D</li> </ol>"},{"location":"Sistemas_Embebidos/Tarea_1/#diseno-de-coche","title":"Dise\u00f1o de coche","text":"<p>Dise\u00f1o de la carcasa utilizada para el proyecto, dise\u00f1ada en Catia V5 adaptada a las necesidades de nuestros sensores, especificaciones t\u00e9cnicas y posteriormente impresa en 3D.  </p>"},{"location":"Sistemas_Embebidos/Tarea_1/#esquematico-y-pcb","title":"Esquem\u00e1tico y PCB","text":"<p>Esquem\u00e1tico 2D de la conecci\u00f3n del circuito del micromouse.</p> <p></p> <p>Esquem\u00e1tico final del dise\u00f1o de la PCB para el micromouse.</p> <p></p>"},{"location":"Sistemas_Embebidos/Tarea_1/#codigo_14","title":"C\u00f3digo","text":"<p>El algoritmo para un robot Micromouse se centra en la exploraci\u00f3n y optimizaci\u00f3n de rutas en un laberinto desconocido, utilizando estrategias para pruebas iniciales como el Algoritmo de la Mano Izquierda (o Derecha) y el Algoritmo FloodFill  para encontrar el camino m\u00e1s corto en la segunda pasada, mapeando el laberinto con sensores para moverse aut\u00f3nomamente y mejorar el rendimiento del trayecto. </p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/i2c.h\"\n#include \"hardware/gpio.h\"\n\n// ==========================================\n// 1. CONFIGURACI\u00d3N DE HARDWARE Y PINES\n// ==========================================\n#define I2C_PORT i2c0\n#define SDA_PIN 4\n#define SCL_PIN 5\n#define MPU6050_ADDR 0x68\n#define PWR_MGMT_1   0x6B\n#define GYRO_XOUT_H  0x43\n#define GYRO_REG_LECTURA (GYRO_XOUT_H + 2) \n\n#define TRIG1 6   // Frontal\n#define ECHO1 7\n#define TRIG2 8   // Izquierdo\n#define ECHO2 9\n#define TRIG3 10  // Derecho\n#define ECHO3 11\n\n#define PWMA 22\n#define AIN1 20\n#define AIN2 21\n#define PWMB 16\n#define BIN1 18\n#define BIN2 17\n#define STBY 19\n#define LED_PIN 25\n\n// ==========================================\n// 2. CONSTANTES\n// ==========================================\n#define MAZE_SIZE 12\nconst uint32_t TIEMPO_CELDA_MS = 955; \nconst float GIRO_ENTRADA = -70.0f;    \nconst float DISTANCIA_OBJETIVO = 3.5f;     \nconst float DISTANCIA_PARED_EXISTE = 9.0f; \nconst int OFFSET_MOTOR_DERECHO = 15; \n\n// Velocidades\nconst int VELOCIDAD_BASE = 105; \nconst int VELOCIDAD_GIRO = 117;     \n\n// Ganancias PID\nconst float KP_CENTER = 8.0f;  \nconst float KD_CENTER = 22.0f; \nconst float KP_WALL   = 10.0f;  \nconst float KD_WALL   = 30.0f; \nconst float KP_GYRO   = 4.5f;  \nconst float KD_GYRO   = 3.5f;  \nconst float KP_GYRO_ASSIST = 1.5f; \nconst float ALPHA_SENSOR = 0.65f; \n\n// ==========================================\n// 3. VARIABLES GLOBALES\n// ==========================================\nconst int DX[4] = {0, 1, 0, -1};\nconst int DY[4] = {1, 0, -1, 0};\n\nuint8_t walls[MAZE_SIZE][MAZE_SIZE];\nuint8_t costs[MAZE_SIZE][MAZE_SIZE];\n\nstruct RobotState {\n    int x; int y; int dir; \n} robot;\n\ntypedef struct { int x, y; } Point;\nPoint queue[MAZE_SIZE * MAZE_SIZE];\n\nfloat y_accum = 0.0f;\nfloat gyro_bias = 0.0f;\nabsolute_time_t last_time;\nfloat prev_error = 0.0f; \n\nvolatile absolute_time_t start_time_1, start_time_2, start_time_3;\nvolatile float dist_val_1 = 100, dist_val_2 = 100, dist_val_3 = 100;\n\n// ==========================================\n// 4. DRIVERS\n// ==========================================\nvoid mpu6050_init() {\n    uint8_t buf[2]; buf[0] = PWR_MGMT_1; buf[1] = 0x00;\n    i2c_write_blocking(I2C_PORT, MPU6050_ADDR, buf, 2, false);\n}\n\nint16_t read_word(uint8_t reg) {\n    uint8_t buf[2];\n    i2c_write_blocking(I2C_PORT, MPU6050_ADDR, &amp;reg, 1, true);\n    i2c_read_blocking(I2C_PORT, MPU6050_ADDR, buf, 2, false);\n    return (buf[0] &lt;&lt; 8) | buf[1];\n}\n\nvoid calibrar_gyro() {\n    long sum = 0;\n    for (int i = 0; i &lt; 200; i++) {\n        sum += read_word(GYRO_REG_LECTURA);\n        sleep_ms(5);\n    }\n    gyro_bias = (float)sum / 200.0f / 131.0f;\n}\n\nvoid update_gyro_angle() {\n    float gyro_val = (read_word(GYRO_REG_LECTURA) / 131.0f) - gyro_bias;\n    if (fabs(gyro_val) &lt; 1.0f) gyro_val = 0; \n    absolute_time_t now = get_absolute_time();\n    y_accum += gyro_val * (absolute_time_diff_us(last_time, now) / 1e6f);\n    last_time = now;\n}\n\nvoid gpio_callback(uint gpio, uint32_t events) {\n    absolute_time_t now = get_absolute_time();\n    if (gpio == ECHO1) {\n        if (events &amp; GPIO_IRQ_EDGE_RISE) start_time_1 = now;\n        else if (events &amp; GPIO_IRQ_EDGE_FALL) dist_val_1 = (absolute_time_diff_us(start_time_1, now) * 0.0343f) / 2.0f;\n    } else if (gpio == ECHO2) {\n        if (events &amp; GPIO_IRQ_EDGE_RISE) start_time_2 = now;\n        else if (events &amp; GPIO_IRQ_EDGE_FALL) dist_val_2 = (absolute_time_diff_us(start_time_2, now) * 0.0343f) / 2.0f;\n    } else if (gpio == ECHO3) {\n        if (events &amp; GPIO_IRQ_EDGE_RISE) start_time_3 = now;\n        else if (events &amp; GPIO_IRQ_EDGE_FALL) dist_val_3 = (absolute_time_diff_us(start_time_3, now) * 0.0343f) / 2.0f;\n    }\n}\n\n// Filtro de \"Locura\" del sensor\nfloat get_dist(int sensor_idx) {\n    float d = 100.0f;\n    if (sensor_idx == 1) d = dist_val_1;\n    else if (sensor_idx == 2) d = dist_val_2;\n    else if (sensor_idx == 3) d = dist_val_3;\n\n    if (d &gt; 400.0f) return 100.0f;\n    if (d &lt;= 0.1f) return 1.0f;\n    if (d &gt; 130.0f &amp;&amp; d &lt; 300.0f) return 1.0f;\n\n    return d;\n}\n\nvoid trigger_sensors() {\n    gpio_put(TRIG1, 1); sleep_us(10); gpio_put(TRIG1, 0); sleep_us(1500);\n    gpio_put(TRIG2, 1); sleep_us(10); gpio_put(TRIG2, 0); sleep_us(1500);\n    gpio_put(TRIG3, 1); sleep_us(10); gpio_put(TRIG3, 0); sleep_us(1500);\n}\n\n// ==========================================\n// 5. MOTORES\n// ==========================================\nuint pwm_setup(uint pin) {\n    gpio_set_function(pin, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(pin);\n    pwm_set_wrap(slice, 255); \n    pwm_set_chan_level(slice, pwm_gpio_to_channel(pin), 0); \n    pwm_set_enabled(slice, true);\n    return slice;\n}\n\nvoid set_motor_speed(uint sliceA, uint sliceB, int speedL, int speedR) {\n    gpio_put(STBY, 1);\n    if (speedR != 0) speedR += OFFSET_MOTOR_DERECHO;\n    if (speedR &gt;= 0) { gpio_put(AIN1, 1); gpio_put(AIN2, 0); }\n    else { gpio_put(AIN1, 0); gpio_put(AIN2, 1); speedR = -speedR; } \n    if (speedR &gt; 255) speedR = 255;\n    pwm_set_chan_level(sliceA, pwm_gpio_to_channel(PWMA), speedR);\n\n    if (speedL &gt;= 0) { gpio_put(BIN1, 1); gpio_put(BIN2, 0); }\n    else { gpio_put(BIN1, 0); gpio_put(BIN2, 1); speedL = -speedL; }\n    if (speedL &gt; 255) speedL = 255;\n    pwm_set_chan_level(sliceB, pwm_gpio_to_channel(PWMB), speedL);\n}\n\nvoid motor_stop_all(uint sliceA, uint sliceB) {\n    pwm_set_chan_level(sliceA, pwm_gpio_to_channel(PWMA), 0);\n    pwm_set_chan_level(sliceB, pwm_gpio_to_channel(PWMB), 0);\n    gpio_put(STBY, 0);\n}\n\nvoid realizar_giro_relativo(uint sliceA, uint sliceB, float grados) {\n    motor_stop_all(sliceA, sliceB); sleep_ms(200);\n    y_accum = 0.0f; last_time = get_absolute_time();\n    int dir = (grados &gt; 0) ? 1 : -1; \n    while (fabs(y_accum) &lt; fabs(grados)) {\n        update_gyro_angle();\n        set_motor_speed(sliceA, sliceB, -VELOCIDAD_GIRO * dir, VELOCIDAD_GIRO * dir);\n        sleep_ms(1);\n    }\n    motor_stop_all(sliceA, sliceB); sleep_ms(200); y_accum = 0.0f;\n}\n\nvoid avanzar_una_celda(uint sliceA, uint sliceB) {\n    const float DISTANCIA_STOP_FRONTAL = 3.3f; \n    absolute_time_t start_move = get_absolute_time();\n    y_accum = 0.0f; last_time = get_absolute_time();\n    prev_error = 0.0f; \n\n    float f_izq = get_dist(2);\n    float f_der = get_dist(3);\n\n    while (absolute_time_diff_us(start_move, get_absolute_time()) &lt; (TIEMPO_CELDA_MS * 1000)) {\n        trigger_sensors(); \n        update_gyro_angle();\n\n        float r_izq = get_dist(2);\n        float r_der = get_dist(3);\n        float s_front = get_dist(1); \n\n        f_izq = (f_izq * ALPHA_SENSOR) + (r_izq * (1.0f - ALPHA_SENSOR));\n        f_der = (f_der * ALPHA_SENSOR) + (r_der * (1.0f - ALPHA_SENSOR));\n\n        if (s_front &lt; DISTANCIA_STOP_FRONTAL) {\n            sleep_ms(78); set_motor_speed(sliceA, sliceB, 0, 0);\n            sleep_ms(50); motor_stop_all(sliceA, sliceB); break; \n        }\n\n        float error = 0.0f;\n        float kp = KP_GYRO, kd = KD_GYRO;\n        bool pared_izq = f_izq &lt; DISTANCIA_PARED_EXISTE;\n        bool pared_der = f_der &lt; DISTANCIA_PARED_EXISTE;\n        float gyro_correction = (0.0f - y_accum) * KP_GYRO_ASSIST;\n\n        if (pared_izq &amp;&amp; pared_der) {\n            error = f_izq - f_der; kp = KP_CENTER; kd = KD_CENTER;\n        } else if (pared_izq) {\n            error = (f_izq - DISTANCIA_OBJETIVO); kp = KP_WALL; kd = KD_WALL; error += gyro_correction;\n        } else if (pared_der) {\n            error = (DISTANCIA_OBJETIVO - f_der); kp = KP_WALL; kd = KD_WALL; error += gyro_correction;\n        } else {\n            error = 0.0f - y_accum; kp = KP_GYRO; kd = KD_GYRO;\n        }\n\n        float derivada = error - prev_error;\n        float salida = (error * kp) + (derivada * kd);\n        prev_error = error;\n        int correccion = (int)salida;\n        if (correccion &gt; 45) correccion = 45; if (correccion &lt; -45) correccion = -45;\n        set_motor_speed(sliceA, sliceB, VELOCIDAD_BASE - correccion, VELOCIDAD_BASE + correccion);\n        sleep_ms(5); \n    }\n    motor_stop_all(sliceA, sliceB); sleep_ms(100);\n}\n\n// ==========================================\n// 6. MAPEO Y FLOOD FILL (META DE 4 CUADROS)\n// ==========================================\nvoid inicializar_laberinto() {\n    for(int i=0; i&lt;MAZE_SIZE; i++) for(int j=0; j&lt;MAZE_SIZE; j++) { walls[i][j] = 0; costs[i][j] = 255; }\n    for(int i=0; i&lt;MAZE_SIZE; i++) {\n        walls[i][0] |= 0x08; walls[i][MAZE_SIZE-1] |= 0x02;\n        walls[0][i] |= 0x04; walls[MAZE_SIZE-1][i] |= 0x01;\n    }\n}\n\nvoid detectar_paredes() {\n    trigger_sensors(); sleep_ms(50); \n    float f = get_dist(1); float l = get_dist(2); float r = get_dist(3);\n\n    bool wall_f = (f &lt; DISTANCIA_PARED_EXISTE);\n    bool wall_l = (l &lt; DISTANCIA_PARED_EXISTE);\n    bool wall_r = (r &lt; DISTANCIA_PARED_EXISTE);\n\n    // OJO: f, l, r pueden ser 1.0f si hubo glitch (get_dist lo hace).\n    bool free_f = (f &gt; 16.0f);\n    bool free_l = (l &gt; 16.0f);\n    bool free_r = (r &gt; 16.0f);\n\n    uint8_t add_mask = 0; uint8_t clear_mask = 0; \n\n    if (robot.dir == 0) { // N\n        if(wall_f) add_mask|=1; else if(free_f) clear_mask|=1;\n        if(wall_r) add_mask|=2; else if(free_r) clear_mask|=2;\n        if(wall_l) add_mask|=8; else if(free_l) clear_mask|=8;\n    } else if (robot.dir == 1) { // E\n        if(wall_f) add_mask|=2; else if(free_f) clear_mask|=2;\n        if(wall_r) add_mask|=4; else if(free_r) clear_mask|=4;\n        if(wall_l) add_mask|=1; else if(free_l) clear_mask|=1;\n    } else if (robot.dir == 2) { // S\n        if(wall_f) add_mask|=4; else if(free_f) clear_mask|=4;\n        if(wall_r) add_mask|=8; else if(free_r) clear_mask|=8;\n        if(wall_l) add_mask|=2; else if(free_l) clear_mask|=2;\n    } else if (robot.dir == 3) { // W\n        if(wall_f) add_mask|=8; else if(free_f) clear_mask|=8;\n        if(wall_r) add_mask|=1; else if(free_r) clear_mask|=1;\n        if(wall_l) add_mask|=4; else if(free_l) clear_mask|=4;\n    }\n\n    walls[robot.x][robot.y] |= add_mask;     \n    walls[robot.x][robot.y] &amp;= ~clear_mask;  \n\n    if(robot.y &lt; MAZE_SIZE-1) { if(add_mask &amp; 1) walls[robot.x][robot.y+1] |= 4; if(clear_mask &amp; 1) walls[robot.x][robot.y+1] &amp;= ~4; }\n    if(robot.x &lt; MAZE_SIZE-1) { if(add_mask &amp; 2) walls[robot.x+1][robot.y] |= 8; if(clear_mask &amp; 2) walls[robot.x+1][robot.y] &amp;= ~8; }\n    if(robot.y &gt; 0)           { if(add_mask &amp; 4) walls[robot.x][robot.y-1] |= 1; if(clear_mask &amp; 4) walls[robot.x][robot.y-1] &amp;= ~1; }\n    if(robot.x &gt; 0)           { if(add_mask &amp; 8) walls[robot.x-1][robot.y] |= 2; if(clear_mask &amp; 8) walls[robot.x-1][robot.y] &amp;= ~2; }\n}\n\nvoid flood_fill_update() {\n    for(int i=0; i&lt;MAZE_SIZE; i++) for(int j=0; j&lt;MAZE_SIZE; j++) costs[i][j] = 255;\n    costs[5][5] = 0; costs[6][5] = 0; costs[5][6] = 0; costs[6][6] = 0;\n    int head = 0, tail = 0;\n    queue[tail++] = (Point){5, 5}; queue[tail++] = (Point){6, 5};\n    queue[tail++] = (Point){5, 6}; queue[tail++] = (Point){6, 6};\n\n    while(head &lt; tail) {\n        Point c = queue[head++];\n        uint8_t cd = costs[c.x][c.y];\n        if (c.y &lt; MAZE_SIZE-1 &amp;&amp; !(walls[c.x][c.y] &amp; 0x01) &amp;&amp; costs[c.x][c.y+1]==255) {\n            costs[c.x][c.y+1] = cd + 1; queue[tail++] = (Point){c.x, c.y+1};\n        }\n        if (c.x &lt; MAZE_SIZE-1 &amp;&amp; !(walls[c.x][c.y] &amp; 0x02) &amp;&amp; costs[c.x+1][c.y]==255) {\n            costs[c.x+1][c.y] = cd + 1; queue[tail++] = (Point){c.x+1, c.y};\n        }\n        if (c.y &gt; 0 &amp;&amp; !(walls[c.x][c.y] &amp; 0x04) &amp;&amp; costs[c.x][c.y-1]==255) {\n            costs[c.x][c.y-1] = cd + 1; queue[tail++] = (Point){c.x, c.y-1};\n        }\n        if (c.x &gt; 0 &amp;&amp; !(walls[c.x][c.y] &amp; 0x08) &amp;&amp; costs[c.x-1][c.y]==255) {\n            costs[c.x-1][c.y] = cd + 1; queue[tail++] = (Point){c.x-1, c.y};\n        }\n    }\n}\n\nint obtener_mejor_direccion() {\n    int best = -1; uint8_t min_cost = 255;\n    if (!(walls[robot.x][robot.y] &amp; 0x01) &amp;&amp; robot.y &lt; MAZE_SIZE-1 &amp;&amp; costs[robot.x][robot.y+1] &lt; min_cost) { \n        min_cost = costs[robot.x][robot.y+1]; best = 0; \n    }\n    if (!(walls[robot.x][robot.y] &amp; 0x02) &amp;&amp; robot.x &lt; MAZE_SIZE-1 &amp;&amp; costs[robot.x+1][robot.y] &lt; min_cost) { \n        min_cost = costs[robot.x+1][robot.y]; best = 1; \n    }\n    if (!(walls[robot.x][robot.y] &amp; 0x04) &amp;&amp; robot.y &gt; 0 &amp;&amp; costs[robot.x][robot.y-1] &lt; min_cost) { \n        min_cost = costs[robot.x][robot.y-1]; best = 2; \n    }\n    if (!(walls[robot.x][robot.y] &amp; 0x08) &amp;&amp; robot.x &gt; 0 &amp;&amp; costs[robot.x-1][robot.y] &lt; min_cost) { \n        min_cost = costs[robot.x-1][robot.y]; best = 3; \n    }\n    return best;\n}\n\nbool es_meta(int x, int y) {\n    return (x &gt;= 5 &amp;&amp; x &lt;= 6 &amp;&amp; y &gt;= 5 &amp;&amp; y &lt;= 6);\n}\n\n// ==========================================\n// 7. PROGRAMA PRINCIPAL\n// ==========================================\nint main() {\n    stdio_init_all();\n    i2c_init(I2C_PORT, 400 * 1000);\n    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C); gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);\n    gpio_pull_up(SDA_PIN); gpio_pull_up(SCL_PIN); mpu6050_init();\n\n    gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_init(TRIG1); gpio_set_dir(TRIG1, GPIO_OUT); gpio_init(ECHO1); gpio_set_dir(ECHO1, GPIO_IN);\n    gpio_init(TRIG2); gpio_set_dir(TRIG2, GPIO_OUT); gpio_init(ECHO2); gpio_set_dir(ECHO2, GPIO_IN);\n    gpio_init(TRIG3); gpio_set_dir(TRIG3, GPIO_OUT); gpio_init(ECHO3); gpio_set_dir(ECHO3, GPIO_IN);\n\n    gpio_set_irq_enabled_with_callback(ECHO1, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(ECHO2, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(ECHO3, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(AIN1); gpio_set_dir(AIN1, GPIO_OUT); gpio_init(AIN2); gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_init(BIN1); gpio_set_dir(BIN1, GPIO_OUT); gpio_init(BIN2); gpio_set_dir(BIN2, GPIO_OUT);\n    gpio_init(STBY); gpio_set_dir(STBY, GPIO_OUT);\n\n    uint sliceA = pwm_setup(PWMA); uint sliceB = pwm_setup(PWMB);\n\n    // ==============================================\n    // FASE 1: EXPLORACI\u00d3N\n    // ==============================================\n    gpio_put(LED_PIN, 1);\n    calibrar_gyro();\n    inicializar_laberinto();\n    robot.x = 0; robot.y = 0; robot.dir = 0; \n    sleep_ms(1000); \n    gpio_put(LED_PIN, 0);\n\n    realizar_giro_relativo(sliceA, sliceB, GIRO_ENTRADA); \n    robot.dir = 1; \n    sleep_ms(200);\n\n    while (true) {\n        if (es_meta(robot.x, robot.y)) {\n            motor_stop_all(sliceA, sliceB);\n            break; \n        }\n\n        detectar_paredes();\n        flood_fill_update(); \n        int next_dir = obtener_mejor_direccion();\n\n        if (next_dir != -1) {\n            int diff = next_dir - robot.dir;\n            if (diff == 3) diff = -1; \n            if (diff == -3) diff = 1; \n\n            if (abs(diff) == 2) {\n                float f = get_dist(1); float l = get_dist(2); float r = get_dist(3);\n                if (l &gt; 15.0f &amp;&amp; l &lt; 60.0f) { diff = -1; next_dir = (robot.dir + 3) % 4; }\n                else if (r &gt; 15.0f &amp;&amp; r &lt; 60.0f) { diff = 1; next_dir = (robot.dir + 1) % 4; }\n            }\n\n            if (diff == 1) realizar_giro_relativo(sliceA, sliceB, -72.0f);     \n            else if (diff == -1) realizar_giro_relativo(sliceA, sliceB, 72.0f); \n            else if (abs(diff) == 2) realizar_giro_relativo(sliceA, sliceB, 155.0f);\n\n            robot.dir = next_dir;\n        }\n\n        trigger_sensors(); sleep_ms(50);\n        if (get_dist(1) &lt; 6.0f) {\n             motor_stop_all(sliceA, sliceB);\n             gpio_put(LED_PIN, 1); sleep_ms(100); gpio_put(LED_PIN, 0);\n             continue; \n        }\n\n        avanzar_una_celda(sliceA, sliceB);\n        robot.x += DX[robot.dir];\n        robot.y += DY[robot.dir];\n    }\n\n    // ==============================================\n    // FASE DE PAUSA\n    // ==============================================\n    for(int k=0; k&lt;40; k++) { \n        gpio_put(LED_PIN, 1); sleep_ms(200); \n        gpio_put(LED_PIN, 0); sleep_ms(200); \n    }\n\n    sleep_ms(2000); \n\n    robot.x = 0; robot.y = 0; robot.dir = 0; \n    y_accum = 0; \n    last_time = get_absolute_time();\n    calibrar_gyro(); \n\n    realizar_giro_relativo(sliceA, sliceB, GIRO_ENTRADA); \n    robot.dir = 1; \n    sleep_ms(500);\n\n    // ==============================================\n    // FASE 2: CARRERA R\u00c1PIDA (SIN MAPEO)\n    // ==============================================\n    while (true) {\n        if (es_meta(robot.x, robot.y)) {\n            motor_stop_all(sliceA, sliceB);\n            while(1) { gpio_put(LED_PIN, 1); sleep_ms(100); gpio_put(LED_PIN, 0); sleep_ms(100); }\n        }\n\n        // AQU\u00cd ESTABA EL ERROR: BORRAMOS detectar_paredes()\n        // detectar_paredes(); &lt;--- \u00a1ELIMINADA!\n\n        flood_fill_update(); \n        int next_dir = obtener_mejor_direccion();\n\n        if (next_dir != -1) {\n            int diff = next_dir - robot.dir;\n            if (diff == 3) diff = -1; \n            if (diff == -3) diff = 1; \n\n            if (diff == 1) realizar_giro_relativo(sliceA, sliceB, -72.0f);     \n            else if (diff == -1) realizar_giro_relativo(sliceA, sliceB, 72.0f); \n            else if (abs(diff) == 2) realizar_giro_relativo(sliceA, sliceB, 155.0f);\n\n            robot.dir = next_dir;\n        }\n\n        avanzar_una_celda(sliceA, sliceB);\n        robot.x += DX[robot.dir];\n        robot.y += DY[robot.dir];\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Sistemas_Embebidos/Tarea_1/#capstone-micromouse-final","title":"Capstone Micromouse FINAL","text":"<p>Imagen representativa del proyecto final ensamblado en su totalidad en funcionamiento</p> <p></p>"},{"location":"Sistemas_Embebidos/Tarea_1/#videos","title":"Videos","text":""}]}